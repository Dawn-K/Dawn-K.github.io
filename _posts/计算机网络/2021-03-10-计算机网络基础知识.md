---
layout: post
title : 「计算机网络」 计算机网络基础知识
date: 2021-03-10
tags: [计算机网络]
categories: [计算机网络]
---

# 计算机网络

[toc]

## OSI 模型

OSI 具有七层，但是其太过理想化，并没有实际采用。
1. 物理层（界定连接器和网线的规格）
2. 数据链路层（相邻设备之间传送和识别数据帧）
3. 网络应用层（地址管理和路由选择）
4. 传输层（端到端的数据连接）
5. 会话层（负责建立和断开通信连接）
6. 表示层（数据格式的转换）
7. 应用层（针对特定应用）

## TCP/IP

TCP/IP 是个协议族。包含了 TCP IP, HTTP, UDP, ICMP 等协议

### TCP 模型

1. 物理层（界定连接器和网线的规格）
2. 数据链路层（相邻设备之间传送和识别数据帧）
3. 网络应用层（地址管理和路由选择）
4. 传输层（端到端的数据连接）
5. 应用层（针对特定应用，合并了会话层，表示层，应用层）

### TCP 是面向流的协议

TCP 是个"流"协议，没有界限的一串数据，从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的 TCP 粘包和拆包问题。
UDP 则没有这个问题。UDP 是基于报文发送的，从 UDP 的帧结构可以看出，在 UDP 首部采用了 16bit 来指示 UDP 数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。

### IP

ip 是无连接的模型，尽力发送，且不维护链接状态
根据数据包的首部的协议字段来分辨 TCP 和 UDP（一个是 6, 一个是 17)

### ICMP

ICMP 协议是一种面向无连接的网络层协议，用于传输出错报告控制信息。
1. 改变路由
2. 源点抑制
3. ping 命令
4. traceroute 命令

### TCP UDP 区别

1. tcp 是面向链接的可靠传输，udp 是无连接的不可靠的
2. tcp 有流量控制和拥塞控制，udp 没有
3. tcp 是两点之间的，udp 可以一对一，一对多，多对一，对对多的通信
4. TCP 首部开销大，首部 20 个字节。UDP 首部开销小，8 字节。（源端口，目的端口，数据长度，校验和）

### socket

socket 编程步骤。
服务端： `socket`  `bind`  `listen`  `accept`  `read`

客户端： `socket`  `connect`  `write`

### 包首部

TCP 包首部含有 20 字节固定的内容。
UDP 包首部含有 8 字节，没有非固定的内容。
IP 包首部含有 20 字节固定的内容。

### 可靠性

#### 如何保证可靠性

序列号，确认应答，超时重传

#### 序列号

这时发送方在等待一定时间后会进行重传。这个时间一般是 2*RTT（报文段往返时间）+一个偏差值。

#### 流量控制

发送端如果收到 3 次相同应答，就会立刻进行重发
但是如果应答丢失了，因为窗口的存在，发送端就不会重发

### 拥塞控制

* 慢开始。一旦出现计时器超时，拥塞窗口变为 1, 然后拥塞阈值降为发生超时时的窗口的一半，然后每经过一个往返时间，窗口就翻倍。
* 拥塞避免。慢开始一旦超过拥塞阈值，每经过一个往返时间就加一。
* 快重传。一旦连续收到三个重复确认，就立即重发。
* 快启动。在快重传的基础上，重发后将拥塞窗口变成一半，阈值也变为一半（和拥塞窗口大小一样）, 然后执行加法增加。

## DHCP

一种局域网的网络协议，由服务器控制一段 IP 地址范围，客户机登录服务器时就可以自动获得服务器分配的 IP 地址和子网掩码。

## 网络模型

### C/S

非对等相互作用，服务器有客户端不具备的硬件和软件资源、运算能力，服务器提供服务，客户请求服务。
多个客户进程可以同时访问一个服务进程，一个客户进程可以同时访问多个服务器提供的服务。

### B/S

BS 是特殊的 CS 模型，其客户端特指浏览器。

## 加密算法

### RSA

[阮一峰-RSA(1): 数学知识](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)
[阮一峰-RSA(2): 算法流程](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)

#### 计算过程

* 第一步选择两个质数 p, q 尽可能大
* 第二步计算` n = p * q `
* 第三步计算` φ(n) = (p-1) * (q-1) `
* 第四步选择一个整数 e, 使得`条件是 1< e < φ(n), 且 e 与φ(n) 互质 `
* 第五步计算 e 关于φ(n) 的逆元 d, 也就是` e*d ≡ 1 (mod φ(n)) `
* 第六步将 (n, e) 封装成公钥，(n, d) 封装成私钥

上述计算过程中只有 n 和 e 公开，其余的 p, q, φ(n), d 均不公开

#### 保密原理

RSA 算法加密的核心就是在于 d 难以通过 n, e 求出来。
要想算出 d, 需要知道φ(n), 而φ(n) 需要知道 p, q, 也就是对 n 进行因式分解。而因式分解很困难。
乘法逆元算法如下，两种算法都可以在知道φ(n) 的情况下实现 e 和 d 的互相求值。因为 e 和 d 互为逆元。

```cpp
#include <algorithm>
#include <iostream>
using namespace std;
typedef long long ll;

// 两个方法，前提是 a,p 互质。不互质时返回-1:
// 1. 费马小定理：a*x≡1(mod p), 则 x=a^(p-2) (mod p)
// 2. 扩展欧几里得算法：那么 ax≡1 (mod p) 即 ax-yp=1. 把 y 写成+的形式就是 ax+py=1，
// 为方便理解下面我们把 p 写成 b 就是 ax+by=1。就表示 x 是 a 的模 b 乘法逆元，y 是 b 的模 a 乘法逆元。

// 快速幂
ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    ll base = a;
    while (b) {
        if (b & 1ll) {
            res = res * base % mod;
        }
        base = base * base % mod;
        b >>= 1;
    }
    return res;
}

void exgcd(ll a, ll b, ll& d, ll& x, ll& y) {
    if (!b) {
        d = a;
        x = 1;
        y = 0;
    } else {
        exgcd(b, a % b, d, y, x);
        y -= x * (a / b);
    }
    printf("%lld*(%lld)+%lld*(%lld)=%lld\n", a, x, b, y, d);
}
ll invByFermat(ll a, ll p) {
    // 欧拉扩展的 Fermat 小定理：如果 gcd(a,n) = 1，则 a(n) mod n = 1。
    // a 的乘法逆元：x=a^euler(n)-1 mod n

    return __gcd(a, p) == 1 ? qpow(a, p - 2, p) : -1;
}

ll invByExgcd(ll a, ll p) {
    ll d, x, y;
    exgcd(a, p, d, x, y);
    return d == 1 ? (x + p) % p : -1;
}

int main() {
    ll a, p;
    // cin >> a >> p;
    a = 1679616;
    p = 11;
    cout << "By Fermat: " << invByFermat(a, p) << endl;
    cout << "By Exgcd: " << invByExgcd(a, p) << endl;
    return 0;
}
```

## http

### 概述

http 是一种无状态的应用层协议。主要应用在浏览网页上，但是也可以用在其他其他，比如即时通信，下载等。HTTP 协议使用 URI 定位互联网上的资源。
客户向服务器请求服务时，只需传送请求方法和路径。**支持 B/S 及 C/S 模式。**

### 持久连接

http 0.9 和 1.0 都使用非持续链接，限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。http 1.1 改为了持续链接，可以传输多个对象。而持久性链接带来的还有请求的管线化，也就是可以在上一个请求尚未回复的时候就发送下一个请求。

### 无状态

http 的无状态意味着它对之前的请求没有记忆，如果需要用到之前的信息，那么需要重新传输，如果不需要，使用起来就节省时间。在需要前后文的场合，一般采用 Cookie 技术。Cookie 技术是说，在首次通信的时候，服务端会在响应中添加 Cookie 信息，然后客户端将其保留，在下次链接的时候，将 Cookie 加入请求，然后服务器就知道之前的状态信息了。

### 工作流程

1.  客户端连接到 Web 服务器

一个 HTTP 客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80) 建立一个 TCP 套接字连接。
2. 发送 HTTP 请求

通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行。请求头部。空行和请求数据 4 部分组成。
3. 服务器接受请求并返回 HTTP 响应

Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。
如

```

HTTP/1.1 200 OK
Date: Tue, 10 Jul 2012 06:50:15 GMT
Content-Length: 362
Content-Type: text/html

<html>
```

4. 释放连接 TCP 连接

若 connection 模式为 close, 则服务器主动关闭 TCP 连接，客户端被动关闭连接，释放 TCP 连接；若 connection 模式为 keepalive, 则该连接会保持一段时间，在该时间内可以继续接收请求；
5. 客户端浏览器解析 HTML 内容

客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML, 根据 HTML 的语法对其进行格式化，并在浏览器窗口中显示。

### 请求

下面是一个真实的请求例子，可以通过 F12 工具里面的 NetWork 看到，是读取百度百科的图标的一个请求，由于 Cookie 太长，就仅仅留了一部分

```

GET /favicon.ico HTTP/1.1
Host: baike.baidu.com
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
sec-ch-ua: "Google Chrome";v="89", "Chromium";v="89", ";Not A Brand";v="99"
sec-ch-ua-mobile: ?0
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: no-cors
Sec-Fetch-Dest: image
Referer: https://baike.baidu.com/item/goto%E8%AF%AD%E5%8F%A5/7603004?fr=aladdin
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,zh-TW;q=0.8,en-US;q=0.7,en;q=0.6
Cookie: BIDUPSID=5BA9C0F9D1F69BCF04F7196693AA0E37; PSTM=1606200267; 
```

HTTP1.0 定义了三种请求方法：GET, POST 和 HEAD 方法。
HTTP1.1 新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。
`GET` 是请求。
`POST` 是提交表单。
`HEAD` 和 GET 基本一样，但是只要求返回头部信息。
`PUT` 是向服务端提交文件。几乎不会使用。
`DELETE` 是删除文件。几乎不会使用。
`TRACE` 是追踪请求的转发路线。几乎不会使用。
`CONNECT` 是要求使用隧道进行代理。
`OPTIONS` 是查看 URI 可以执行的动作。

### https

HTTP 本身是明文协议。每个 HTTP 请求和返回的每个 byte 都会在网络上明文传播，不管是 url, header 还是 body. 

SSL(Secure Sockets Layer 安全套接字协议）, 及其继任者传输层安全 (Transport Layer Security, TLS) 是在传输层和应用层之间对信息进行加密。
通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS, 其实就是身披 SSL 协议这层外壳的 HTTP. 加密采用混合加密的方式，先用公开密钥方式传输对称密钥，后续的信息就用对称密钥加密的方式。这样既保证了安全性，又保证了效率。
SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。
SSL 提供认证和加密处理及摘要功能。也就是用以防范中间人攻击，保证下载文件的正确性和完整性。常规的校验码的方式都需要用户手动检查，而且检验码本身也可能被篡改。
https 采用 443 端口

#### 客户端服务端验证过程

1. 首先客户端通过 URL 访问服务器建立 SSL 连接。
2. 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。（这里补充一步客户端验证证书）
3. 客户端的服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。
4. 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
5. 服务器利用自己的私钥解密出会话密钥。
6. 服务器利用会话密钥加密与客户端之间的通信。

#### 客户端验证证书过程

1: 客户端验证证书内容有效性（过期时间，域名是否相同等）
2: 验证证书的有效性 （是否被串改）, 通过本地根证书的 CA 公钥解密数字摘要，看是否匹配。
3: 如果数字签名验证通过，就可以使用服务器证书里面提供的公钥进行下一步通信。
**综上，HTTPS = HTTP + 加密 + 认证 + 完整性保护。**
[链接流程]( https://zhuanlan.zhihu.com/p/72616216 )

## 设备

## 集线器

集线器工作在数据链路层，多个端口，无方向性的传送信息包，没有地址转换功能。集线器内部共享带宽。

## 网桥

网桥工作在数据链路层，将两个 LAN 连起来，根据 MAC 地址来转发帧，可以看作一个"低层的路由器"（路由器工作在网络层，根据网络地址如 IP 地址进行转发）. 网桥可以看作是一个低层的交换机 .

## 交换机

交换机其实就是多端口的网桥。也是数据链路层，但是能够让设备独享带宽。

## 路由器

路由器工作在网络层，可以有方向地发送信息包。
