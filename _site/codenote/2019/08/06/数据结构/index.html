<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="From ashes to the empire">
    <meta name="keywords" content="Dawnk, Dawn-K, dawnk, Dawn-K's Blog, 博客, 个人网站, ACM , 算法竞赛">
    <meta name="theme-color" content="#000000">

    <!-- Open Graph -->
    <meta property="og:title"
        content="「CodeNote」 数据结构 - Dawn-K's Blog">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="数据结构
">
    
    <meta property="article:published_time" content=" 2019-08-06T00:00:00Z">
    
    
    
    <meta property="article:tag" content="CodeNote">
    
    
    <meta property="og:image" content="http://dawnk.gitee.io//img/daze.jpg">
    <meta property="og:url" content="http://dawnk.gitee.io//codenote/2019/08/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
    <meta property="og:site_name" content="Dawn-K's Blog">

    <title>「CodeNote」 数据结构 - Dawn-K's Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">

    <!-- Canonical URL -->
    <link rel="canonical" href="http://dawnk.gitee.io//codenote/2019/08/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href=" /css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href=" /css/hux-blog.min.css">

    <!-- <link rel="stylesheet" href="http://yandex.st/highlightjs/7.1/styles/default.min.css">
    <script src="http://yandex.st/highlightjs/7.1/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script> -->
    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet"
        type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
        type="text/javascript"></script>

    <!-- ga & ba script hoook -->
    <script></script>
</head>

<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->

    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">Dawn-K's Blog</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div id="huxblog_navbar">
                <div class="navbar-collapse">
                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="/">Home</a>
                        </li>
                        
                        
                        
                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                        
                        
                        <li>
                            <a href="/archive/">Archive</a>
                        </li>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <li class="search-icon">
                            <a href="javascript:void(0)">
                                <i class="fa fa-search"></i>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <script>
        // Drop Bootstarp low-performance Navbar
        // Use customize navbar with high-quality material design animation
        // in high-perf jank-free CSS3 implementation
        var $body = document.body;
        var $toggle = document.querySelector('.navbar-toggle');
        var $navbar = document.querySelector('#huxblog_navbar');
        var $collapse = document.querySelector('.navbar-collapse');

        var __HuxNav__ = {
            close: function () {
                $navbar.className = " ";
                // wait until animation end.
                setTimeout(function () {
                    // prevent frequently toggle
                    if ($navbar.className.indexOf('in') < 0) {
                        $collapse.style.height = "0px"
                    }
                }, 400)
            },
            open: function () {
                $collapse.style.height = "auto"
                $navbar.className += " in";
            }
        }

        // Bind Event
        $toggle.addEventListener('click', function (e) {
            if ($navbar.className.indexOf('in') > 0) {
                __HuxNav__.close()
            } else {
                __HuxNav__.open()
            }
        })

        /**
         * Since Fastclick is used to delegate 'touchstart' globally
         * to hack 300ms delay in iOS by performing a fake 'click',
         * Using 'e.stopPropagation' to stop 'touchstart' event from 
         * $toggle/$collapse will break global delegation.
         * 
         * Instead, we use a 'e.target' filter to prevent handler
         * added to document close HuxNav.  
         *
         * Also, we use 'click' instead of 'touchstart' as compromise
         */
        document.addEventListener('click', function (e) {
            if (e.target == $toggle) return;
            if (e.target.className == 'icon-bar') return;
            __HuxNav__.close();
        })
    </script>
    <!-- Search -->
<div class="search-page">
  <div class="search-icon-close-container">
    <span class="search-icon-close">
      <i class="fa fa-chevron-down"></i>
    </span>
  </div>
  <div class="search-main container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <form></form>
        <input type="text" id="search-input" placeholder="$ grep...">
        </form>
        <div id="search-results" class="mini-post-list"></div>
      </div>
    </div>
  </div>
</div>

    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/home-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/home-bg.jpg');
        background: ;
    }

    
</style>

<header class="intro-header" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/archive/?tag=CodeNote" title="CodeNote">CodeNote</a>
                        
                    </div>
                    <h1>「CodeNote」 数据结构</h1>
                    
                    <h2 class="subheading"></h2>
                    <span class="meta">Posted by Dawn-K's Blog on August 6, 2019</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<h1 id="数据结构">数据结构</h1>

<h2 id="划分树">划分树</h2>

<p><a href="https://www.cnblogs.com/shinianhuanniyijuhaojiubujian/p/9157906.html">参考博客-十年换你一句好久不见</a></p>

<h3 id="结构">结构</h3>

<blockquote>
  <p><strong>划分树</strong>是基于<strong>线段树</strong>的一种数据结构，主要用于快速求出(log(n)时间的时间复杂度内))序列区间的<strong>第K大/小值</strong></p>
</blockquote>

<p>划分树主要分为两部分:<strong>建树</strong>和<strong>查询</strong></p>

<h3 id="建树">建树</h3>

<p><img src="https://images2018.cnblogs.com/blog/1118135/201806/1118135-20180608235037825-1383480240.png" alt="划分树图示" /></p>

<p>如图所示,划分树本质上是<strong>线段树加模拟快速排序</strong>.</p>

<p>首先我们先创建一个数组<code class="language-plaintext highlighter-rouge">sorted[]</code>,用以保存原数组排序后的结果.和<code class="language-plaintext highlighter-rouge">toleft[]</code>,用以<strong>记录当前节点及之前节点被分到左子树的个数(后文会详细解释)</strong></p>

<p>然后树的主体我们采用<code class="language-plaintext highlighter-rouge">tree[][]</code>这个二维数组来实现,第一维是层,第二维是数组元素</p>

<p>递归建树过程,主体思想是</p>

<ul>
  <li>针对区间[L,R],我们根据<code class="language-plaintext highlighter-rouge">sorted[(L+R)/2]</code>来将这个数组一分为二,将小的放到左子树(即此层分裂后下一层的左侧的区间),大的放到右侧.</li>
  <li>然后更改一下toleft数组,记录当前节点及之前节点被分到左子树的个数</li>
  <li>向左右子树递归,当区间长度为1时终止</li>
</ul>

<p>但是上文的操作会带来一个问题,就是如果中位数有重复的情况怎么办,其实解决方法也简单,就是手动维护让左右两个区间的个数仍然是各为一半就可以了</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span><span class="o">=</span><span class="mi">100010</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">tree</span><span class="p">[</span><span class="mi">30</span><span class="p">][</span><span class="n">MAXN</span><span class="p">];</span><span class="c1">// 表示每层每个位置的值</span>
<span class="kt">int</span> <span class="n">sorted</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span><span class="c1">// 已经排序的数,这个是从1开始的</span>
<span class="kt">int</span> <span class="n">toleft</span><span class="p">[</span><span class="mi">30</span><span class="p">][</span><span class="n">MAXN</span><span class="p">];</span><span class="c1">// toleft[p][i]表示第i层从1到i有多少个数分入左边</span>

<span class="kt">void</span> <span class="nf">build</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="kt">int</span> <span class="n">dep</span><span class="p">){</span> <span class="c1">// 建树</span>
    <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">==</span><span class="n">r</span><span class="p">)</span> <span class="c1">// 终止条件,区间长度为1 </span>
        <span class="k">return</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">mid</span><span class="o">=</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">same</span><span class="o">=</span><span class="n">mid</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="c1">// same表示等于中间值而且预计要分入左边的个数</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">l</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 数出多少个重复的中位数 </span>
      <span class="k">if</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">sorted</span><span class="p">[</span><span class="n">mid</span><span class="p">]){</span>
         <span class="n">same</span><span class="o">--</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">lpos</span><span class="o">=</span><span class="n">l</span><span class="p">;</span> <span class="c1">// 左边界</span>
    <span class="kt">int</span> <span class="n">rpos</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 右边界</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">l</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="c1">// 对于每个元素都讨论是分向左边还是右边</span>
        <span class="k">if</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">sorted</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span><span class="c1">// 比中间的数小，分入左边</span>
             <span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">lpos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">sorted</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="n">same</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span> <span class="c1">// 与中间数相等,此处通过讨论same,来判断左侧还需不需要填入与中位数相等的数,如果需要,就加入</span>
            <span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">lpos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="n">same</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>  <span class="c1">// 比中间值大,分入右边</span>
            <span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">rpos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
        <span class="n">toleft</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">toleft</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">lpos</span><span class="o">-</span><span class="n">l</span><span class="p">;</span><span class="c1">// 前缀思想,记录从1到i放左边的个数</span>
    <span class="p">}</span>
    <span class="c1">// 向左右子树递归</span>
    <span class="n">build</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">dep</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">build</span><span class="p">(</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">dep</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="查询">查询</h3>

<p>数据结构的形式决定其使用的方法,针对这种数据结构,不难发现,其查询也一定是<strong>向下递归,逐步缩小区间,然后定位某个数为最终答案</strong>.</p>

<p>首先,我们先定义接口<code class="language-plaintext highlighter-rouge">int query(int L,int R,int l,int r,int dep,int k);</code>[L,R]是大区间,[l,r]是查询小区间,dep是层次,k即”第K小”</p>

<p>查询时,如果查询区间长度变成1,则查询终止,目标已找到.若区间长度大于1,则最后的答案一定位于其左右孩子区间的其中一个,所以只需要向下查询即可.</p>

<p>至于向下查询,我们不难想到,如果其左孩子中的元素个数大于k,则答案一定在左子树中,否则一定在右子树中,这也就是向左还是向右搜索的判断条件.</p>

<p>注:以上二分的是大区间,但对于查询区间(小区间),仍然需要讨论</p>

<p>仔细思索,发现小区间在向下传递的过程中是应该发生变化的,(以向左孩子区间传递为例)因为在[l,r]区间中向左区间传递的数量是不定的,可能很多,然后l就会变小.可能很少,l就会变大,所以l,r应该根据[l,r]区间向左子树传递的个数来确定.</p>

<p>至于具体方法,不难发现,<strong>[L,l-1]内被分配到左子树的元素,不在查找之列</strong>，但相对位置不变，这些元素一定排在前面(因为先被加入到下一层)，以此来确定左边界,其个数是<code class="language-plaintext highlighter-rouge">toleft[l-1]-toleft[L-1]</code>,所以 <code class="language-plaintext highlighter-rouge">newl=L+toleft[dep][l-1]-toleft[dep][L-1]</code></p>

<p>我们再对向右区间传递的情况进行讨论,我们发现,在r之前的元素,无论是分配到了左区间还是右区间,都对r的位置没有影响,但是在[r+1,R]区间中的元素如果分到的左区间,则会导致r的右移,也就是会导致r右移<code class="language-plaintext highlighter-rouge">toleft[dep][R]-toleft[dep][r]</code>个单位,同理新的l也可以由新的r来确定,即<code class="language-plaintext highlighter-rouge">newl == newr - [l,r]中转移到右侧的元素个数 == newr - ([l,r]区间长度 - [l,r]中转移的左侧的元素个数)</code>,即<code class="language-plaintext highlighter-rouge">newl = newr - (r-l-cnt)</code></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="c1">//查询区间第k大的数，[L,R]是大区间，[l,r]是要查询的小区间</span>
<span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">R</span><span class="p">,</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="kt">int</span> <span class="n">dep</span><span class="p">,</span><span class="kt">int</span> <span class="n">k</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">==</span><span class="n">r</span><span class="p">)</span> <span class="c1">// 区间长度为1,即终止条件</span>
        <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">l</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">mid</span><span class="o">=</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="n">R</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cnt</span><span class="o">=</span><span class="n">toleft</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">toleft</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span><span class="c1">// [l,r]中位于左边的个数</span>
    <span class="k">if</span><span class="p">(</span><span class="n">cnt</span><span class="o">&gt;=</span><span class="n">k</span><span class="p">){</span> <span class="c1">// 答案在左区间</span>
        <span class="c1">// L+要查询的区间前被放在左边的个数</span>
        <span class="kt">int</span> <span class="n">newl</span><span class="o">=</span><span class="n">L</span><span class="o">+</span><span class="n">toleft</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">toleft</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
        <span class="c1">// 左端点加上查询区间会被放在左边的个数</span>
        <span class="kt">int</span> <span class="n">newr</span><span class="o">=</span><span class="n">newl</span><span class="o">+</span><span class="n">cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">newl</span><span class="p">,</span><span class="n">newr</span><span class="p">,</span><span class="n">dep</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span> <span class="c1">// 答案在右区间</span>
        <span class="c1">// 同理此处先确定右端点,再确定左端点</span>
         <span class="kt">int</span> <span class="n">newr</span><span class="o">=</span><span class="n">r</span><span class="o">+</span><span class="n">toleft</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">R</span><span class="p">]</span><span class="o">-</span><span class="n">toleft</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">r</span><span class="p">];</span>
         <span class="kt">int</span> <span class="n">newl</span><span class="o">=</span><span class="n">newr</span><span class="o">-</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">-</span><span class="n">cnt</span><span class="p">);</span>
         <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">newl</span><span class="p">,</span><span class="n">newr</span><span class="p">,</span><span class="n">dep</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="n">cnt</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="使用方法">使用方法</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
</pre></td><td class="rouge-code"><pre><span class="c1">// 求第k小模板性很强</span>
<span class="cm">/*
HDU  2665 Kth number
划分树
*/</span>
<span class="cp">#include&lt;stdio.h&gt;
#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;algorithm&gt;
</span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">MAXN</span><span class="o">=</span><span class="mi">100010</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">tree</span><span class="p">[</span><span class="mi">30</span><span class="p">][</span><span class="n">MAXN</span><span class="p">];</span><span class="c1">//表示每层每个位置的值</span>
<span class="kt">int</span> <span class="n">sorted</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span><span class="c1">//已经排序的数</span>
<span class="kt">int</span> <span class="n">toleft</span><span class="p">[</span><span class="mi">30</span><span class="p">][</span><span class="n">MAXN</span><span class="p">];</span><span class="c1">//toleft[p][i]表示第i层从1到i有多少个数分入左边</span>

<span class="kt">void</span> <span class="nf">build</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="kt">int</span> <span class="n">dep</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">==</span><span class="n">r</span><span class="p">)</span><span class="k">return</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">mid</span><span class="o">=</span><span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">same</span><span class="o">=</span><span class="n">mid</span><span class="o">-</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span><span class="c1">//表示等于中间值而且被分入左边的个数</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">l</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">sorted</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
         <span class="n">same</span><span class="o">--</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">lpos</span><span class="o">=</span><span class="n">l</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rpos</span><span class="o">=</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">l</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">r</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">sorted</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span><span class="c1">//比中间的数小，分入左边</span>
             <span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">lpos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">sorted</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="n">same</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
            <span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">lpos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="n">same</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>  <span class="c1">//比中间值大分入右边</span>
            <span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">rpos</span><span class="o">++</span><span class="p">]</span><span class="o">=</span><span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
        <span class="n">toleft</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">toleft</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">lpos</span><span class="o">-</span><span class="n">l</span><span class="p">;</span><span class="c1">//从1到i放左边的个数</span>
    <span class="p">}</span>
    <span class="n">build</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">dep</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">build</span><span class="p">(</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">dep</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">//查询区间第k大的数，[L,R]是大区间，[l,r]是要查询的小区间</span>
<span class="kt">int</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">L</span><span class="p">,</span><span class="kt">int</span> <span class="n">R</span><span class="p">,</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="kt">int</span> <span class="n">dep</span><span class="p">,</span><span class="kt">int</span> <span class="n">k</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">l</span><span class="o">==</span><span class="n">r</span><span class="p">)</span><span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">l</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">mid</span><span class="o">=</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="n">R</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cnt</span><span class="o">=</span><span class="n">toleft</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">r</span><span class="p">]</span><span class="o">-</span><span class="n">toleft</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span><span class="c1">//[l,r]中位于左边的个数</span>
    <span class="k">if</span><span class="p">(</span><span class="n">cnt</span><span class="o">&gt;=</span><span class="n">k</span><span class="p">){</span>
        <span class="c1">//L+要查询的区间前被放在左边的个数</span>
        <span class="kt">int</span> <span class="n">newl</span><span class="o">=</span><span class="n">L</span><span class="o">+</span><span class="n">toleft</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">toleft</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
        <span class="c1">//左端点加上查询区间会被放在左边的个数</span>
        <span class="kt">int</span> <span class="n">newr</span><span class="o">=</span><span class="n">newl</span><span class="o">+</span><span class="n">cnt</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">L</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">newl</span><span class="p">,</span><span class="n">newr</span><span class="p">,</span><span class="n">dep</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
         <span class="kt">int</span> <span class="n">newr</span><span class="o">=</span><span class="n">r</span><span class="o">+</span><span class="n">toleft</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">R</span><span class="p">]</span><span class="o">-</span><span class="n">toleft</span><span class="p">[</span><span class="n">dep</span><span class="p">][</span><span class="n">r</span><span class="p">];</span>
         <span class="kt">int</span> <span class="n">newl</span><span class="o">=</span><span class="n">newr</span><span class="o">-</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="o">-</span><span class="n">cnt</span><span class="p">);</span>
         <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">newl</span><span class="p">,</span><span class="n">newr</span><span class="p">,</span><span class="n">dep</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="n">cnt</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">T</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">k</span><span class="p">;</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">T</span><span class="p">);</span>
    <span class="k">while</span><span class="p">(</span><span class="n">T</span><span class="o">--</span><span class="p">){</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">,</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
        <span class="n">memset</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">tree</span><span class="p">));</span><span class="c1">// 这个必须</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="c1">// 从1开始</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">sorted</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="c1">// 先排序sorted[]数组</span>
        <span class="n">sort</span><span class="p">(</span><span class="n">sorted</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">sorted</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
        <span class="c1">// 然后从第0层开始初始化</span>
        <span class="n">build</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">while</span><span class="p">(</span><span class="n">m</span><span class="o">--</span><span class="p">){</span>
            <span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span><span class="o">&amp;</span><span class="n">k</span><span class="p">);</span>
            <span class="c1">// 下面函数参数中的1,n,0都是固定的,即从[1,n]的第0层开始</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">query</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">k</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="应用未完">应用(未完)</h3>

<p>我们不难发现,求区间第k大的算法就是上文的query,我们根据中学知识可得,中位数的大小就是区间里第<code class="language-plaintext highlighter-rouge">(len+1)/2</code>大的数</p>

<p>此处给出一个题,先mark一下,过几天更新答案</p>

<p><a href="https://www.cnblogs.com/kuangbin/archive/2012/08/16/2641088.html">HDU 3473 - kuangbin</a></p>

<h2 id="主席树">主席树</h2>

<p><a href="https://www.cnblogs.com/zyf0163/p/4749042.html">参考博客- 殇雪</a></p>

<p>又叫<strong>可持久化线段树</strong>,</p>

<blockquote>
  <p>主席树就是利用<strong>函数式编程的思想</strong>来使线段树支持询问历史版本、同时充分利用它们之间的共同数据来减少时间和空间消耗的增强版的线段树。</p>
</blockquote>

<p>此处mark一下,之后补充</p>

<h2 id="伸展树splay-tree">伸展树(Splay tree)</h2>

<p><a href="https://blog.csdn.net/skydec/article/details/20151805">伸展树讲解</a></p>

<p>[<算法合集之伸展树的基本操作和应用>](https://max.book118.com/html/2017/0810/127135517.shtm)</算法合集之伸展树的基本操作和应用></p>

<p>伸展树是一种<strong>自平衡二叉搜索树</strong>,其特点是通过旋转来获得较好的平摊时间复杂度,也就是未必保证每一次的操作都是O(lg N),<strong>但是连续m次的均摊复杂度不大于O(M*lg N)</strong>,而且不像AVL一样需要额外的空间来记录树的平衡状况,其操作也比红黑树要简单,编码难度低,因此在竞赛中经常使用</p>

<p>伸展树常用的操作有 插入,查询,删除,求最大值,最小值,求前驱,求后继,合并,分离</p>

<h2 id="模板">模板</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
</pre></td><td class="rouge-code"><pre><span class="c1">// kuangbin 的模板</span>
<span class="cp">#define MAXN 2000000
</span><span class="kt">int</span> <span class="n">ch</span><span class="p">[</span><span class="n">MAXN</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">fa</span><span class="p">[</span><span class="n">MAXN</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">root</span><span class="p">,</span> <span class="n">tot</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">splaInit</span><span class="p">(){</span> <span class="c1">// 初始化</span>
    <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">tot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">newNode</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">father</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 新建节点,在创建根节点时只能采取这个方式构造: newNode(root,a,0)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="o">++</span><span class="n">tot</span><span class="p">;</span>
    <span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">father</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">rotate</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">kind</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//kind = 0 ,左旋，kind = 1 ,右旋</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
    <span class="n">ch</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="o">!</span><span class="n">kind</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">kind</span><span class="p">];</span>
    <span class="n">fa</span><span class="p">[</span><span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">kind</span><span class="p">]]</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">y</span><span class="p">])</span><span class="n">ch</span><span class="p">[</span><span class="n">fa</span><span class="p">[</span><span class="n">y</span><span class="p">]][</span><span class="n">ch</span><span class="p">[</span><span class="n">fa</span><span class="p">[</span><span class="n">y</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[</span><span class="n">y</span><span class="p">];</span>
    <span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="n">fa</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Splay</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">goal</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//将节点x转到节点goal下面</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">goal</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fa</span><span class="p">[</span><span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]]</span> <span class="o">==</span> <span class="n">goal</span><span class="p">)</span><span class="n">rotate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ch</span><span class="p">[</span><span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">);</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="n">fa</span><span class="p">[</span><span class="n">y</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">kind</span> <span class="o">=</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">z</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">kind</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">rotate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">!</span><span class="n">kind</span><span class="p">);</span>
                <span class="n">rotate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kind</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">rotate</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="p">);</span>
                <span class="n">rotate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">kind</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">goal</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 此时根节点已经发生了变化,变成了x</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 向伸展树中插入元素</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span><span class="c1">//避免重复插入</span>
            <span class="n">Splay</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">newNode</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="n">Splay</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 本质是求左子树的最大值</span>
<span class="kt">int</span> <span class="nf">get_pree</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 寻找前驱(实际上返回的是前驱节点在data数组中的下标),若无前驱,则返回-1</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="c1">//没有前驱</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 本质是求右子树的最小值</span>
<span class="kt">int</span> <span class="nf">get_next</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 寻找后继(实际上返回的是前驱节点在data数组中的下标),若无后继,则返回-1</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="c1">//没有后继</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">splaInit</span><span class="p">();</span>
 	<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">tmp</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="p">){</span>
            <span class="n">insert</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span> <span class="c1">// 此处可通过insert函数的返回值来判断是否插入成功(插入不成功的情况是已经存在与之相同大小的元素)</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="n">newNode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">tmp</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span> 
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
</pre></td><td class="rouge-code"><pre><span class="c1">// Clove_unique 的模板,正确性稍后验证</span>
<span class="c1">// 然而这个版本有一点点问题,在于其求前驱和后继的方法不太方便而且插入并不返回正确与否,所以决定进行修改,与kuangbin 的进行结合</span>
<span class="cp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
</span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#define MAXN 1000000
</span><span class="kt">int</span> <span class="n">ch</span><span class="p">[</span><span class="n">MAXN</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="n">f</span><span class="p">[</span><span class="n">MAXN</span><span class="p">],</span><span class="n">size</span><span class="p">[</span><span class="n">MAXN</span><span class="p">],</span><span class="n">cnt</span><span class="p">[</span><span class="n">MAXN</span><span class="p">],</span><span class="n">key</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">sz</span><span class="p">,</span><span class="n">root</span><span class="p">;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
	<span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="n">size</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="n">cnt</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="n">key</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">inline</span> <span class="n">bool</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
	<span class="k">return</span> <span class="n">ch</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">){</span>
		<span class="n">size</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="n">cnt</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="n">size</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">+=</span><span class="n">size</span><span class="p">[</span><span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="n">size</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">+=</span><span class="n">size</span><span class="p">[</span><span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]];</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">old</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="n">oldf</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">old</span><span class="p">],</span><span class="n">whichx</span><span class="o">=</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="n">ch</span><span class="p">[</span><span class="n">old</span><span class="p">][</span><span class="n">whichx</span><span class="p">]</span><span class="o">=</span><span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">whichx</span><span class="o">^</span><span class="mi">1</span><span class="p">];</span> <span class="n">f</span><span class="p">[</span><span class="n">ch</span><span class="p">[</span><span class="n">old</span><span class="p">][</span><span class="n">whichx</span><span class="p">]]</span><span class="o">=</span><span class="n">old</span><span class="p">;</span>
	<span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">whichx</span><span class="o">^</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">old</span><span class="p">;</span> <span class="n">f</span><span class="p">[</span><span class="n">old</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
	<span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="n">oldf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">oldf</span><span class="p">)</span>
		<span class="n">ch</span><span class="p">[</span><span class="n">oldf</span><span class="p">][</span><span class="n">ch</span><span class="p">[</span><span class="n">oldf</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">old</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
	<span class="n">update</span><span class="p">(</span><span class="n">old</span><span class="p">);</span> <span class="n">update</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">splay</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fa</span><span class="p">;</span><span class="n">fa</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">];</span><span class="n">rotate</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">fa</span><span class="p">])</span>
	    <span class="n">rotate</span><span class="p">((</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="n">get</span><span class="p">(</span><span class="n">fa</span><span class="p">))</span><span class="o">?</span><span class="n">fa</span><span class="o">:</span><span class="n">x</span><span class="p">);</span>
	<span class="n">root</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span><span class="n">sz</span><span class="o">++</span><span class="p">;</span> <span class="n">ch</span><span class="p">[</span><span class="n">sz</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">ch</span><span class="p">[</span><span class="n">sz</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">root</span><span class="o">=</span><span class="n">sz</span><span class="p">;</span> <span class="n">size</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span><span class="o">=</span><span class="n">cnt</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">key</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">;</span> <span class="k">return</span><span class="p">;}</span>
	<span class="kt">int</span> <span class="n">now</span><span class="o">=</span><span class="n">root</span><span class="p">,</span><span class="n">fa</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="n">key</span><span class="p">[</span><span class="n">now</span><span class="p">]){</span>
			<span class="n">cnt</span><span class="p">[</span><span class="n">now</span><span class="p">]</span><span class="o">++</span><span class="p">;</span> <span class="n">update</span><span class="p">(</span><span class="n">now</span><span class="p">);</span> <span class="n">update</span><span class="p">(</span><span class="n">fa</span><span class="p">);</span> <span class="n">splay</span><span class="p">(</span><span class="n">now</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fa</span><span class="o">=</span><span class="n">now</span><span class="p">;</span>
		<span class="n">now</span><span class="o">=</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="n">key</span><span class="p">[</span><span class="n">now</span><span class="p">]</span><span class="o">&lt;</span><span class="n">x</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">now</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>
			<span class="n">sz</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ch</span><span class="p">[</span><span class="n">sz</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">ch</span><span class="p">[</span><span class="n">sz</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
			<span class="n">f</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span><span class="o">=</span><span class="n">fa</span><span class="p">;</span>
			<span class="n">size</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span><span class="o">=</span><span class="n">cnt</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">ch</span><span class="p">[</span><span class="n">fa</span><span class="p">][</span><span class="n">key</span><span class="p">[</span><span class="n">fa</span><span class="p">]</span><span class="o">&lt;</span><span class="n">x</span><span class="p">]</span><span class="o">=</span><span class="n">sz</span><span class="p">;</span>
			<span class="n">key</span><span class="p">[</span><span class="n">sz</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
			<span class="n">update</span><span class="p">(</span><span class="n">fa</span><span class="p">);</span>
			<span class="n">splay</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">now</span><span class="o">=</span><span class="n">root</span><span class="p">,</span><span class="n">ans</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="n">key</span><span class="p">[</span><span class="n">now</span><span class="p">])</span>
		  <span class="n">now</span><span class="o">=</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">else</span><span class="p">{</span>
			<span class="n">ans</span><span class="o">+=</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">?</span><span class="n">size</span><span class="p">[</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">:</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="n">key</span><span class="p">[</span><span class="n">now</span><span class="p">]){</span>
				<span class="n">splay</span><span class="p">(</span><span class="n">now</span><span class="p">);</span> <span class="k">return</span> <span class="n">ans</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ans</span><span class="o">+=</span><span class="n">cnt</span><span class="p">[</span><span class="n">now</span><span class="p">];</span>
			<span class="n">now</span><span class="o">=</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">findx</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">now</span><span class="o">=</span><span class="n">root</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">size</span><span class="p">[</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
		  <span class="n">now</span><span class="o">=</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">else</span><span class="p">{</span>
			<span class="kt">int</span> <span class="n">temp</span><span class="o">=</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">?</span><span class="n">size</span><span class="p">[</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span><span class="o">:</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="n">cnt</span><span class="p">[</span><span class="n">now</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;=</span><span class="n">temp</span><span class="p">)</span> <span class="k">return</span> <span class="n">key</span><span class="p">[</span><span class="n">now</span><span class="p">];</span>
			<span class="n">x</span><span class="o">-=</span><span class="n">temp</span><span class="p">;</span> <span class="n">now</span><span class="o">=</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pre</span><span class="p">(){</span>
	<span class="kt">int</span> <span class="n">now</span><span class="o">=</span><span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="n">now</span><span class="o">=</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">now</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">next</span><span class="p">(){</span>
	<span class="kt">int</span> <span class="n">now</span><span class="o">=</span><span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="n">now</span><span class="o">=</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">now</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">del</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">){</span>
	<span class="kt">int</span> <span class="n">whatever</span><span class="o">=</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">){</span><span class="n">cnt</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="o">--</span><span class="p">;</span> <span class="n">update</span><span class="p">(</span><span class="n">root</span><span class="p">);</span> <span class="k">return</span><span class="p">;}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">&amp;&amp;!</span><span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span><span class="n">clear</span><span class="p">(</span><span class="n">root</span><span class="p">);</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="k">return</span><span class="p">;}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">0</span><span class="p">]){</span>
		<span class="kt">int</span> <span class="n">oldroot</span><span class="o">=</span><span class="n">root</span><span class="p">;</span> <span class="n">root</span><span class="o">=</span><span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span> <span class="n">f</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">clear</span><span class="p">(</span><span class="n">oldroot</span><span class="p">);</span> <span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">1</span><span class="p">]){</span>
		<span class="kt">int</span> <span class="n">oldroot</span><span class="o">=</span><span class="n">root</span><span class="p">;</span> <span class="n">root</span><span class="o">=</span><span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span> <span class="n">f</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">clear</span><span class="p">(</span><span class="n">oldroot</span><span class="p">);</span> <span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">leftbig</span><span class="o">=</span><span class="n">pre</span><span class="p">(),</span><span class="n">oldroot</span><span class="o">=</span><span class="n">root</span><span class="p">;</span>
	<span class="n">splay</span><span class="p">(</span><span class="n">leftbig</span><span class="p">);</span>
	<span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">ch</span><span class="p">[</span><span class="n">oldroot</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">f</span><span class="p">[</span><span class="n">ch</span><span class="p">[</span><span class="n">oldroot</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="n">root</span><span class="p">;</span>
	<span class="n">clear</span><span class="p">(</span><span class="n">oldroot</span><span class="p">);</span>
	<span class="n">update</span><span class="p">(</span><span class="n">root</span><span class="p">);</span> 
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="kt">int</span> <span class="n">n</span><span class="p">,</span><span class="n">opt</span><span class="p">,</span><span class="n">x</span><span class="p">;</span>
	<span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
		<span class="n">scanf</span><span class="p">(</span><span class="s">"%d%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">opt</span><span class="p">,</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">opt</span><span class="p">){</span>
			<span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="n">del</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> <span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">4</span><span class="p">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">findx</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> <span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">5</span><span class="p">:</span> <span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">key</span><span class="p">[</span><span class="n">pre</span><span class="p">()]);</span> <span class="n">del</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">6</span><span class="p">:</span> <span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">key</span><span class="p">[</span><span class="n">next</span><span class="p">()]);</span> <span class="n">del</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
</pre></td><td class="rouge-code"><pre><span class="c1">// 经过改进与融合,我们得到了如下版本(kuangbin + Clove_unique)的版本,支持插入(可根据返回值判断是否插入成功),删除,寻找前驱,寻找后继,根据值查询名次,和根据名次查询值,且AC了BZOJ的模板题(普通二叉树)</span>
<span class="cp">#include&lt;iostream&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include &lt;cmath&gt;
</span>
<span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="cp">#define MAXN 1000000
</span><span class="kt">int</span> <span class="n">ch</span><span class="p">[</span><span class="n">MAXN</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">MAXN</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="n">MAXN</span><span class="p">],</span> <span class="n">cnt</span><span class="p">[</span><span class="n">MAXN</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">tot</span><span class="p">,</span> <span class="n">root</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">abs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">clear</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="n">bool</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ch</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">size</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="n">size</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">size</span><span class="p">[</span><span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="n">size</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+=</span> <span class="n">size</span><span class="p">[</span><span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">1</span><span class="p">]];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">old</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">oldf</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">old</span><span class="p">],</span> <span class="n">whichx</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="n">ch</span><span class="p">[</span><span class="n">old</span><span class="p">][</span><span class="n">whichx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">whichx</span> <span class="o">^</span> <span class="mi">1</span><span class="p">];</span>
    <span class="n">f</span><span class="p">[</span><span class="n">ch</span><span class="p">[</span><span class="n">old</span><span class="p">][</span><span class="n">whichx</span><span class="p">]]</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
    <span class="n">ch</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">whichx</span> <span class="o">^</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>
    <span class="n">f</span><span class="p">[</span><span class="n">old</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldf</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">oldf</span><span class="p">)</span>
        <span class="n">ch</span><span class="p">[</span><span class="n">oldf</span><span class="p">][</span><span class="n">ch</span><span class="p">[</span><span class="n">oldf</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">old</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">update</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>
    <span class="n">update</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">splay</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">fa</span><span class="p">;</span> <span class="n">fa</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">x</span><span class="p">];</span> <span class="n">rotate</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">fa</span><span class="p">])</span>
            <span class="n">rotate</span><span class="p">((</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="n">get</span><span class="p">(</span><span class="n">fa</span><span class="p">))</span> <span class="o">?</span> <span class="n">fa</span> <span class="o">:</span> <span class="n">x</span><span class="p">);</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tot</span><span class="o">++</span><span class="p">;</span>
        <span class="n">ch</span><span class="p">[</span><span class="n">tot</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">tot</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">tot</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">tot</span><span class="p">;</span>
        <span class="n">size</span><span class="p">[</span><span class="n">tot</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">[</span><span class="n">tot</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">data</span><span class="p">[</span><span class="n">tot</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">now</span> <span class="o">=</span> <span class="n">root</span><span class="p">,</span> <span class="n">fa</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="n">now</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">cnt</span><span class="p">[</span><span class="n">now</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="n">update</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
            <span class="n">update</span><span class="p">(</span><span class="n">fa</span><span class="p">);</span>
            <span class="n">splay</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="n">now</span><span class="p">;</span>
        <span class="n">now</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tot</span><span class="o">++</span><span class="p">;</span>
            <span class="n">ch</span><span class="p">[</span><span class="n">tot</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">tot</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">f</span><span class="p">[</span><span class="n">tot</span><span class="p">]</span> <span class="o">=</span> <span class="n">fa</span><span class="p">;</span>
            <span class="n">size</span><span class="p">[</span><span class="n">tot</span><span class="p">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="p">[</span><span class="n">tot</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">ch</span><span class="p">[</span><span class="n">fa</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="n">fa</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">tot</span><span class="p">;</span>
            <span class="n">data</span><span class="p">[</span><span class="n">tot</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
            <span class="n">update</span><span class="p">(</span><span class="n">fa</span><span class="p">);</span>
            <span class="n">splay</span><span class="p">(</span><span class="n">tot</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">now</span> <span class="o">=</span> <span class="n">root</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">now</span><span class="p">])</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="n">size</span><span class="p">[</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="n">now</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">splay</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">ans</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">ans</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">[</span><span class="n">now</span><span class="p">];</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">findx</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">now</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="p">[</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">?</span> <span class="n">size</span><span class="p">[</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">cnt</span><span class="p">[</span><span class="n">now</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">temp</span><span class="p">)</span> <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">now</span><span class="p">];</span>
            <span class="n">x</span> <span class="o">-=</span> <span class="n">temp</span><span class="p">;</span>
            <span class="n">now</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">pre</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">now</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="n">now</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">now</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">next</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">now</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="n">now</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">now</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">now</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">get_pree</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="c1">//没有前驱</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">get_next</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span><span class="c1">//没有后继</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">del</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">whatever</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">cnt</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cnt</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="n">update</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">clear</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="n">root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">oldroot</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">f</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">clear</span><span class="p">(</span><span class="n">oldroot</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">oldroot</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">f</span><span class="p">[</span><span class="n">root</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">clear</span><span class="p">(</span><span class="n">oldroot</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">leftbig</span> <span class="o">=</span> <span class="n">pre</span><span class="p">(),</span> <span class="n">oldroot</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">splay</span><span class="p">(</span><span class="n">leftbig</span><span class="p">);</span>
    <span class="n">ch</span><span class="p">[</span><span class="n">root</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">oldroot</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">f</span><span class="p">[</span><span class="n">ch</span><span class="p">[</span><span class="n">oldroot</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">clear</span><span class="p">(</span><span class="n">oldroot</span><span class="p">);</span>
    <span class="n">update</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">opt</span><span class="p">,</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">opt</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">opt</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">del</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">findx</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">get_pree</span><span class="p">(</span><span class="n">root</span><span class="p">)]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                <span class="n">del</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="mi">6</span><span class="p">:</span>
                <span class="n">insert</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">get_next</span><span class="p">(</span><span class="n">root</span><span class="p">)]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
                <span class="n">del</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="nl">default:</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>



                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/codenote/2019/08/06/%E6%95%B0%E4%BD%8Ddp/" data-toggle="tooltip" data-placement="top" title="「CodeNote」 数位dp">
                        Previous<br>
                        <span>「CodeNote」 数位dp</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/codenote/2019/08/06/%E6%95%B0%E8%AE%BA%E5%88%9D%E6%8E%A2/" data-toggle="tooltip" data-placement="top" title="「CodeNote」 数论初探">
                        Next<br>
                        <span>「CodeNote」 数论初探</span>
                        </a>
                    </li>
                    
                </ul>
                <hr style="visibility: hidden;">

                

                
            </div>  

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                


<section>
    
        <hr class="hidden-sm hidden-xs">
    
    <h5><a href="/archive/">FEATURED TAGS</a></h5>
    <div class="tags">
        
        
        
        
        
        
                <a data-sort="0091" 
                    href="/archive/?tag=CodeNote"
                    title="CodeNote"
                    rel="92">CodeNote</a>
        
                <a data-sort="0156" 
                    href="/archive/?tag=Web%E5%BC%80%E5%8F%91"
                    title="Web开发"
                    rel="27">Web开发</a>
        
                <a data-sort="0170" 
                    href="/archive/?tag=%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"
                    title="软件工程"
                    rel="13">软件工程</a>
        
                <a data-sort="0170" 
                    href="/archive/?tag=SpringBoot"
                    title="SpringBoot"
                    rel="13">SpringBoot</a>
        
                <a data-sort="0174" 
                    href="/archive/?tag=%E4%BA%92%E8%81%94%E7%BD%91%E6%9E%B6%E6%9E%84"
                    title="互联网架构"
                    rel="9">互联网架构</a>
        
                <a data-sort="0176" 
                    href="/archive/?tag=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0"
                    title="垃圾回收的算法和实现"
                    rel="7">垃圾回收的算法和实现</a>
        
                <a data-sort="0176" 
                    href="/archive/?tag=%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"
                    title="设计模式"
                    rel="7">设计模式</a>
        
                <a data-sort="0176" 
                    href="/archive/?tag=android"
                    title="android"
                    rel="7">android</a>
        
                <a data-sort="0177" 
                    href="/archive/?tag=DAO"
                    title="DAO"
                    rel="6">DAO</a>
        
                <a data-sort="0178" 
                    href="/archive/?tag=%E6%95%B0%E6%8D%AE%E5%BA%93"
                    title="数据库"
                    rel="5">数据库</a>
        
                <a data-sort="0178" 
                    href="/archive/?tag=Python"
                    title="Python"
                    rel="5">Python</a>
        
                <a data-sort="0178" 
                    href="/archive/?tag=Vue"
                    title="Vue"
                    rel="5">Vue</a>
        
                <a data-sort="0179" 
                    href="/archive/?tag=Unity"
                    title="Unity"
                    rel="4">Unity</a>
        
                <a data-sort="0179" 
                    href="/archive/?tag=VSCode%E5%AD%A6%E4%B9%A0"
                    title="VSCode学习"
                    rel="4">VSCode学习</a>
        
                <a data-sort="0180" 
                    href="/archive/?tag=%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6"
                    title="版本控制"
                    rel="3">版本控制</a>
        
                <a data-sort="0180" 
                    href="/archive/?tag=Linux"
                    title="Linux"
                    rel="3">Linux</a>
        
                <a data-sort="0180" 
                    href="/archive/?tag=View"
                    title="View"
                    rel="3">View</a>
        
                <a data-sort="0181" 
                    href="/archive/?tag=C%2B%2B"
                    title="C++"
                    rel="2">C++</a>
        
                <a data-sort="0181" 
                    href="/archive/?tag=Java"
                    title="Java"
                    rel="2">Java</a>
        
                <a data-sort="0181" 
                    href="/archive/?tag=Kotlin"
                    title="Kotlin"
                    rel="2">Kotlin</a>
    </div>
</section>


                <!-- Friends Blog -->
                
<hr>
<h5>FRIENDS</h5>
<ul class="list-inline">
  
  <li><a href="http://www.criinal.com/">Criinal</a></li>
  
</ul>

            </div>
        </div>
    </div>
</article>

<!-- add support for mathjax by voleking-->









<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'right',
          // icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  
  
  
  
  
  <li>
    <a target="_blank" href="https://github.com/Dawn-K">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; Dawn-K's Blog 2022
                    <br>
                    Powered by <a href="http://huangxuan.me">Hux Blog</a> |
                    <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="100px"
                        height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Simple Jekyll Search -->
<script src="/js/simple-jekyll-search.min.js"></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
        var d = document, t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
        s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->







<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function () {
        var $nav = document.querySelector("nav");
        if ($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->



<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog(selector) {

        // interop with multilangual 
        if ('' == 'true') {
            _containerSelector = 'div.post-container.active'
        } else {
            _containerSelector = 'div.post-container'
        }

        // init
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        // clean
        $(selector).html('')

        // appending
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>



<!-- Multi-Lingual -->


<!-- Simple Jekyll Search -->
<script>
    // https://stackoverflow.com/questions/1912501/unescape-html-entities-in-javascript
    function htmlDecode(input) {
        var e = document.createElement('textarea');
        e.innerHTML = input;
        // handle case of empty input
        return e.childNodes.length === 0 ? "" : e.childNodes[0].nodeValue;
    }

    SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('search-results'),
        json: '/search.json',
        searchResultTemplate: '<div class="post-preview item"><a href="{url}"><h2 class="post-title">{title}</h2><h3 class="post-subtitle">{subtitle}</h3><hr></a></div>',
        noResultsText: 'No results',
        limit: 50,
        fuzzy: false,
        // a hack to get escaped subtitle unescaped. for some reason, 
        // post.subtitle w/o escape filter nuke entire search.
        templateMiddleware: function (prop, value, template) {
            if (prop === 'subtitle' || prop === 'title') {
                if (value.indexOf("code")) {
                    return htmlDecode(value);
                } else {
                    return value;
                }
            }
        }
    });

    $(document).ready(function () {
        var $searchPage = $('.search-page');
        var $searchOpen = $('.search-icon');
        var $searchClose = $('.search-icon-close');
        var $searchInput = $('#search-input');
        var $body = $('body');

        $searchOpen.on('click', function (e) {
            e.preventDefault();
            $searchPage.toggleClass('search-active');
            var prevClasses = $body.attr('class') || '';
            setTimeout(function () {
                $body.addClass('no-scroll');
            }, 400)

            if ($searchPage.hasClass('search-active')) {
                $searchClose.on('click', function (e) {
                    e.preventDefault();
                    $searchPage.removeClass('search-active');
                    $body.attr('class', prevClasses);  // from closure 
                });
                $searchInput.focus();
            }
        });
    });
</script>


<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
