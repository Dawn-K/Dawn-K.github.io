<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dawn-K's Blog</title>
    <description>From ashes to the empire</description>
    <link>http://dawnk.gitee.io//</link>
    <atom:link href="http://dawnk.gitee.io//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 06 Feb 2022 22:31:08 +0800</pubDate>
    <lastBuildDate>Sun, 06 Feb 2022 22:31:08 +0800</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>「垃圾回收的算法和实现」 第七章-分代垃圾回收</title>
        <description>&lt;h1 id=&quot;分代垃圾回收&quot;&gt;分代垃圾回收&lt;/h1&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;分代垃圾回收基于这样一个事实：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;很多对象出生不久就会死亡&lt;/li&gt;
  &lt;li&gt;已经存在了很久的对象在未来一段时间内大概率还是存活&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;分代垃圾回收并没有创造新的算法，而是根据代的不同而采用不同的算法。对象刚创建是新生代，然后存活一段时间后就 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;晋升&lt;/code&gt; 老年代。&lt;/p&gt;

&lt;p&gt;JVM 中就是这个算法。&lt;/p&gt;

&lt;h2 id=&quot;ungar-的分代垃圾回收&quot;&gt;Ungar 的分代垃圾回收&lt;/h2&gt;

&lt;p&gt;堆空间总的分为两个，一个是新生代空间，一个是老年代空间。其中新生代空间有分为生成空间和幸存者空间 from 和幸存者空间 to.&lt;/p&gt;

&lt;p&gt;除了堆之外，我们还需要一个数组，称之为记录集，它用来记录老年代对新生代的引用。&lt;/p&gt;

&lt;p&gt;在新生代空间中，对象产生于生成空间，在生成空间满的时候进行 gc，生成空间和 from 都向 to 进行 gc 复制算法。然后切换 from 和 to 的名字。记录集的作用就是用来记录老年代对象对新对象的引用。&lt;/p&gt;

&lt;p&gt;当新生代通过晋升将老年代塞满的时候执行老年代 gc，是标记清扫法。&lt;/p&gt;

&lt;h3 id=&quot;记录集&quot;&gt;记录集&lt;/h3&gt;

&lt;p&gt;记录集往往设置为指向对新生代对象有引用的老年代对象。这是为了能够修复引用。&lt;/p&gt;

&lt;p&gt;书中提到了一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;写屏障&lt;/code&gt; 的概念，这个我存在一些疑惑，和搜到的不一样。&lt;/p&gt;

&lt;p&gt;一个对象头中有三个信息&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;age 只对新生代对象有效&lt;/li&gt;
  &lt;li&gt;remembered , 老年代对象只看这个&lt;/li&gt;
  &lt;li&gt;forwarded 只对新生代对象有效，是一个布尔值，用于 gc 复制，表示是否复制完成了。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 在这里的意思基本和之前 UpdatePtr 是一个使用时机&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// obj 对象的 field 域指向了 newObj 对象&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;writeBarrier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;field&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 如果 obj 是一个没有在记录集的老年代对象&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 指向的 newObj 是新生代对象&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldStart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldStart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remembered&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 加入记录集&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rsIdx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remembered&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 真正的指向&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;field&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 生成空间如果不足就 gc，对象只能生成在生成空间（不能生成在幸存空间）&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newFree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;surviveStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;minorGC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newFree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;surviveStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;allocationFail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forwarded&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remembered&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newFree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 这里不去考虑如果生存空间和 from 活动对象超过了 to 空间大小的情况&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里比较复杂，先语言描述一下。&lt;/p&gt;

&lt;h3 id=&quot;minorgc&quot;&gt;minorGC&lt;/h3&gt;

&lt;p&gt;首先向 to 空间执行 gc 复制算法，如果对象的 age 还没到上限，那么就正常复制，否则就晋升到老年代。&lt;strong&gt;我们不讨论 to 空间不足的情况。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;然后遍历新对象的 children 对象，如果子对象不在老年代，就使用前文的 writeBarrier 进行记录集的增添。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;minorGC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;roots&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 只处理新生代的对象&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 遍历记录集，从记录集中找到活动对象&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rsIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;hasMinorObj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// （经历过 gc 复制算法后）没有指向新生代的子对象 就从记录集中删掉它&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hasMinorObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;emembered&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rsIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rsIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fromStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 已经复制完毕的&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forwarded&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forwarding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AGEMAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 复制到 to&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copyData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toFree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forwarded&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chlid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;promote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;promote&quot;&gt;promote&lt;/h3&gt;

&lt;p&gt;对象的 forwarded 标签用于表示它有没有已经被赋值。&lt;/p&gt;

&lt;p&gt;晋升到老年代的操作 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;promote&lt;/code&gt; ：如果老年代空间不足，就进行老年代 gc，再不足就报错。复制到老年代之后，让原来的对象的 forwarded 为 True，forwarding 指向刚才的新对象。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;promote&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allocateInOld&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 如果老生代没有空间，就尝试清理&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 老年代 gc 就是标记清扫算法&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;majorGC&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;allocateInOld&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;allocationFail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forwarded&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remembered&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 检查是否需要加入记录集&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chlid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rsIndex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;cp&quot;&gt;#rsIndex++; 
&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remembered&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;评价&quot;&gt;评价&lt;/h3&gt;

&lt;p&gt;这个算法的优化完全建立在”刚产生的对象比产生很久的对象更容易变成垃圾“这个经验上。&lt;/p&gt;

&lt;p&gt;在一般情况下能够起到比较好的效果，但是并不符合这个规律的效果甚至不如普通 gc 算法。&lt;/p&gt;
</description>
        <pubDate>Thu, 27 Jan 2022 00:00:00 +0800</pubDate>
        <link>http://dawnk.gitee.io//%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/2022/01/27/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
        <guid isPermaLink="true">http://dawnk.gitee.io//%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/2022/01/27/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
        
        <category>垃圾回收的算法和实现</category>
        
        
        <category>垃圾回收的算法和实现</category>
        
      </item>
    
      <item>
        <title>「垃圾回收的算法和实现」 第六章-保守式 GC</title>
        <description>&lt;h1 id=&quot;保守式-gc&quot;&gt;保守式 GC&lt;/h1&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;保守式 GC 并不是一种算法。而是要针对之前的一些问题进行更现实的讨论。&lt;/p&gt;

&lt;p&gt;比如我们之前的所有判断都基于一点，就是算法本身能直接分辨出一个域是指针还是其他类型。这个实际上是不一定的。我们可以假设一种语言，这种语言本身没有 gc，gc 只是作为一个附加库存在的，gc 面对内存时，只能看见一个一个的字节。&lt;/p&gt;

&lt;p&gt;在这种情况下，普通类型是很容易被误认为指针的。比如前文复用对象的域的 forward。换言之也就是&lt;strong&gt;根不明确了&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;保守式 GC 是说，通过几个简单的规则排除掉指针之后，剩下的只要可能指向堆中某个对象的元素我们都认为是指针，也就是宁可少回收一些垃圾，也不误回收一个。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;是不是正确被对齐的值（32 位机上是 4 的倍数）&lt;/li&gt;
  &lt;li&gt;是不是指向堆内&lt;/li&gt;
  &lt;li&gt;是不是指向对象的开头&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第三条主要是之前提到的 BiBop 法&lt;/p&gt;

&lt;p&gt;这样的话就不需要语言级别的支持，但是有两个致命缺陷&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对堆内存使用不充分&lt;/li&gt;
  &lt;li&gt;能使用的 GC 算法有限，因为保守，所以所有能挪动对象的 GC 算法都没法使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;准确式-gc&quot;&gt;准确式 GC&lt;/h2&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;为了识别准确的根，有一个简单的方法，但是需要语言处理系统的支持。就是我们利用指针的后两位都是 0 的特性，对于所有数字，我们都左移一位，然后最右边置 1(x«1&lt;/td&gt;
      &lt;td&gt;1), 如果溢出就换大一号的类型来存。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这样我们只需要看最后一位了，如果是 1 就是数字，否则就是 0. 这一个技巧也可以用来实现前文提到的 tag 之类的操作。总之就是多了一位存储空间。&lt;/p&gt;

&lt;p&gt;准确式 GC 的优点在于能够充分利用堆空间，每次都能清理干净。缺点是必须有语言处理的支持，而且会导致运行缓慢。&lt;/p&gt;

&lt;h2 id=&quot;句柄引用&quot;&gt;句柄引用&lt;/h2&gt;

&lt;p&gt;这个方法的思路在于，不直接让根指向对象。让根指向一个对象句柄（可以理解为一个指针数组）根指向其中的元素，元素又指向对象。就可以把根和对象解耦，如果对象的位置修改了，就不需要修改根本身了。&lt;/p&gt;

&lt;p&gt;这种方法就可以使用所有的 GC 回收算法了，但是依旧是拖慢了运行速度（因为多了一层引用）&lt;/p&gt;

&lt;p&gt;后面还有个 MostlyCopingGC，累了，鸽了。&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Jan 2022 00:00:00 +0800</pubDate>
        <link>http://dawnk.gitee.io//%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/2022/01/26/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BF%9D%E5%AE%88%E5%BC%8FGC/</link>
        <guid isPermaLink="true">http://dawnk.gitee.io//%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/2022/01/26/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%BF%9D%E5%AE%88%E5%BC%8FGC/</guid>
        
        <category>垃圾回收的算法和实现</category>
        
        
        <category>垃圾回收的算法和实现</category>
        
      </item>
    
      <item>
        <title>「垃圾回收的算法和实现」 第五章-标记压缩算法</title>
        <description>&lt;h1 id=&quot;标记压缩算法&quot;&gt;标记压缩算法&lt;/h1&gt;

&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;

&lt;p&gt;标记压缩算法也是移动对象进行垃圾回收的算法。不过和 gc 复制不同的是，它自始至终只使用一个空间。每次复制的时候，都是向堆的低地址端进行复制，就像把所有活动对象一口气挤到了最左端，把垃圾挤没了一样。&lt;/p&gt;

&lt;p&gt;算法实际上是不可能一遍就直接把对象给挪到合适的位置的。因为如果直接挪动的话，会无法修正其指向子对象的指针。&lt;/p&gt;

&lt;p&gt;所以需要两次扫描，一次先设定好这个对象要去的位置，把指针也修正好。第二次真正的开始进行挪移。&lt;/p&gt;

&lt;p&gt;最开始的方案可以理解为要保证对象在内存中的相对顺序，所以采用了三遍的方式。在遍历之前先进行标记，然后第一遍是设定位置，第二遍是修正指针，第三遍是挪动对象。这种算法我们称为 Lisp2 算法。&lt;/p&gt;

&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$scan&lt;/code&gt; 表示正在下一个要扫描的对象的首地址
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$free&lt;/code&gt; 表示如果挪动的话空闲位置的首地址
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$startStart&lt;/code&gt; 堆的首地址&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
&lt;span class=&quot;c1&quot;&gt;//  在标记后调用&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;compactionPhase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;setForwardPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adjustPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;moveObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 设置每个对象的新位置&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;setForwardPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapStart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 引用&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 修正指针&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;adjustPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;roots&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapStart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 引用&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;moveObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;roots&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 这里顺带把 free 也给维护了，方便之后使用&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapStart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 同理此处还是当做引用&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;copyData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;优点&quot;&gt;优点&lt;/h2&gt;

&lt;p&gt;显然标记压缩算法获得了接近两倍于 gc 复制算法的堆的利用效率。只需要额外记录 forward 和 mark 即可。&lt;/p&gt;

&lt;p&gt;相比于标记清扫算法，能够更有效的利用堆。&lt;/p&gt;

&lt;h2 id=&quot;缺点&quot;&gt;缺点&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;STW 时间长，正比于堆中所有对象的数量。&lt;/li&gt;
  &lt;li&gt;搜索三次，导致每次搜索时间都会很长。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;优化&quot;&gt;优化&lt;/h2&gt;

&lt;h3 id=&quot;two-finger-算法&quot;&gt;Two-Finger 算法&lt;/h3&gt;

&lt;p&gt;TF 算法的思想是指经历两次扫描来进行优化。但是它有个严重的制约条件： &lt;strong&gt;所有对象大小必须一致&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;第一次扫描，使用双指针，将所有右侧的对象都填到左边的空位中。左侧的指针叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$free&lt;/code&gt; , 右侧的叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$live&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;第二次扫描，修正所有子对象的指针。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 移动对象&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;moveObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;live&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;live&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;live&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;live&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 事实上，所有对象的 size 都是一样的&lt;/span&gt;
            &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;live&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;live&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;live&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;live&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;copyData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;live&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;live&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;live&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;adjustPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;roots&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 这里算是个优化，只需要动 $free 后面的对象即可，前面的原有的对象不会动的&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapStart&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 同上文&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里的 forward 指针不必放在头中，可以放在第一个域里面。只需要两次扫描。&lt;/p&gt;

&lt;p&gt;但是缺点也很明显，对象大小一致这个太过苛刻。可以尝试与前文的 BiBop 方法结合。另外此算法也对缓存不友好。&lt;/p&gt;

&lt;h3 id=&quot;表格算法&quot;&gt;表格算法&lt;/h3&gt;

&lt;p&gt;表格算法也是两次扫描，不过保证了先后顺序。这个算法是一群一群的挪动，而且采用表格而不是 forward 来操控。&lt;/p&gt;

&lt;p&gt;首先算法通过扫描，每当扫出一个连续的对象群，就会获得以下信息：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;这个对象群之前的空闲位置的首地址&lt;/li&gt;
  &lt;li&gt;这个对象群的长度&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们就这样一个一个地将对象群挪放到其前面的空闲位置，也就是向左挤压，然后在他们后面放置一个表格用来记录这对象群的信息，以用来稍后修复指针。&lt;/p&gt;

&lt;p&gt;表格可以理解成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt;&lt;/code&gt; ，每个元素记录一个对象群的原起始位置以及滑动的距离（也就是新旧首地址之差）&lt;/p&gt;

&lt;p&gt;先将对象群移动到左端，然后在原来它存在的区间最后一个位置的后一个位置（也就是存放区间的超尾）放一个表格&lt;/p&gt;

&lt;p&gt;然后移动下一个对象群的时候，是很有可能覆盖掉前一个表对象群的表格的，先在超尾存放自己的表格额，然后把之前的表格都放到这个表格后面。所以表格的顺序并不一定是按照对象群首地址的位置排列的。&lt;/p&gt;

&lt;p&gt;所以在之后的更新指针就需要做额外的工作。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;adjustPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;roots&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapStart&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mark&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 寻找 obj 的新地址&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;newAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// table 中是一个 pair&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bestSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bestAddress&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bestPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 寻找首地址小于等于 obj 的元素的最大值&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bestAddress&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bestSize&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; 
            &lt;span class=&quot;n&quot;&gt;bestAddress&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;优点-1&quot;&gt;优点&lt;/h4&gt;

&lt;p&gt;优点是不需要多余的空间，还保持了所有对象的顺序，并且还不需要规定每个对象的大小&lt;/p&gt;

&lt;h4 id=&quot;缺点-1&quot;&gt;缺点&lt;/h4&gt;

&lt;p&gt;缺点也很明显，引入了维护表格的开销，虽然可以通过对表格排序来将查找过程变为二分查找，但是排序本身也有损耗。&lt;/p&gt;
</description>
        <pubDate>Sun, 23 Jan 2022 00:00:00 +0800</pubDate>
        <link>http://dawnk.gitee.io//%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/2022/01/23/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/</link>
        <guid isPermaLink="true">http://dawnk.gitee.io//%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/2022/01/23/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/</guid>
        
        <category>垃圾回收的算法和实现</category>
        
        
        <category>垃圾回收的算法和实现</category>
        
      </item>
    
      <item>
        <title>「垃圾回收的算法和实现」 第四章-GC 复制算法</title>
        <description>&lt;h1 id=&quot;gc-复制算法&quot;&gt;GC 复制算法&lt;/h1&gt;

&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;

&lt;p&gt;之前提到的标记清扫和引用计数法都不会更改对象的位置，并且利用了全部的内存。在此我们就打破这个限制。&lt;/p&gt;

&lt;p&gt;首先我们把内存分成两半，一半叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;from&lt;/code&gt; , 一半叫 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;to&lt;/code&gt; 。每次程序运行时只占用 from，当需要垃圾回收的时候，就先找到所有的活动对象，然后复制到 to 中，并且从 to 的低地址陆续摆放。然后交换 from 和 to 的名字。&lt;/p&gt;

&lt;p&gt;这个算法的关键是不仅要把对象搬运过来，还要把对象之间的引用给修正了。这里也是假定了对象至少有一个域，我们把这个域称为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;forward&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;在对象还是在 from 中的活动对象的时候，这个 forward 就可以认为不存在，因为这是对象的成员的一部分。而当对象复制到 to 之后的时候，原来的对象就没用了，我们就取它的第一个字节为 forward，用来记录对象复制到 to 之后的新地址。&lt;/p&gt;

&lt;p&gt;值得一提的是：由于 from 和 to 本身都是连续的地址（但是 from 和 to 的地址未必是连续的，这里只需要记录下 from 和 to 的开始和结尾四个变量即可，实际上用了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$heapSize/2&lt;/code&gt; ）所以&lt;strong&gt;可以瞬间判断一个地址是属于 from 还是 to，进而判断它有没有被复制完成。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;但是我们暂时不用这种方法，仍然是采用多设置一个 obj.tag，如果为 1，也就是 COPYED, 就表示已经复制了，否则就没有复制。&lt;/p&gt;

&lt;p&gt;经过上述分析不难发现，这个算法是不会在内存中产生碎片的。因为内存的空闲位置一定在 from 的高地址位置连续。所以也不需要空闲链表，只需要看看 from 空间末尾还有没有位置即可。&lt;/p&gt;

&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;

&lt;p&gt;全局变量&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$fromStart&lt;/code&gt; : from 的起始地址
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$toStart&lt;/code&gt; : to 的起始地址
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$heapSize&lt;/code&gt; : 整个堆的大小
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$toFree&lt;/code&gt; : 目前 to 的空闲的位置的首地址
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$free&lt;/code&gt; : 目前 from 空间的空闲位置的首地址&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// from 空间不足&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 这里是假设堆只有 from 和 to 两个空间&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;copying&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;allocationFail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
    &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 将所有对象都复制到 to 中&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;copying&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;roots&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toFree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 复制单个对象并且&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// obj 是旧对象&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COPYED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;COPYED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toFree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 这里实际上是个引用，就是引用自己复制后的对象，修正新对象的儿子指针的指向。&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 如果儿子没被复制就复制，如果被复制了就会返回新地址&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copying&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;优点&quot;&gt;优点&lt;/h2&gt;

&lt;p&gt;GC 复制算法优点很多。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;没有碎片。因为每次复制之后，活动对象都紧紧挨着，所以没有碎片。&lt;/li&gt;
  &lt;li&gt;分配对象速度快。只需要判断 from 的末尾是否能放开这个对象即可，不需要。&lt;/li&gt;
  &lt;li&gt;只对活动对象进行分配，所以算法的复杂度就是标记的复杂度（正比于活动对象的个数）和复制的复杂度（也是正比于活动对象的个数）&lt;/li&gt;
  &lt;li&gt;对缓存友好。在复制之后，所有有引用关系的对象都会尽可能挨着（因为是 dfs 序排放）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;缺点&quot;&gt;缺点&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;最大的缺点就是只有一半的内存使用效率。&lt;/li&gt;
  &lt;li&gt;不兼容保守式 gc。也就是说我们必须重写指针，这是之前的算法所没有的。&lt;/li&gt;
  &lt;li&gt;采用了 dfs，有爆栈的风险。事实上这是一个比较好解决的方案，我们接下来就会解决它。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;优化&quot;&gt;优化&lt;/h2&gt;

&lt;h3 id=&quot;cheney-gc-复制算法&quot;&gt;Cheney GC 复制算法&lt;/h3&gt;

&lt;p&gt;这个算法思路非常巧妙。之前提到担心 dfs 会爆栈，所以我们就可以采用 bfs，但是 bfs 不也是有空间消耗吗？此算法就拿 to 空间本身加上一些指针就把 to 当做了队列来使用。&lt;/p&gt;

&lt;p&gt;首先要复制根直接指向的对象（不递归）。&lt;/p&gt;

&lt;p&gt;然后设置队首指针 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scan&lt;/code&gt; ，指向 to 空间的首地址。 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$toFree&lt;/code&gt; 表示 to 空间的第一个空闲的首地址。&lt;/p&gt;

&lt;p&gt;然后进入循环，扫描队首对象的子对象，如果没有在队列中，就放到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;toFree&lt;/code&gt; 的位置，然后 toFree 向后移动。当处理完队首对象，scan 就向后移动。&lt;/p&gt;

&lt;p&gt;注意这个算法顺便还取消了 tag，所有的对象都按照 forward 指针的值来判断是否已经复制了。这个原理我们在本章前文已经讲述了。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// copy 所有对象&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;copying&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toFree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;roots&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copyObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// scan == $toFree 表示队列为空&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toFree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copyObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fromStart&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;，$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;copyObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 实际上这里的 obj 必然是一个在 from 空间的对象，所以必须要看其 forward&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 已经复制完了&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toFree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;toFree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;heapSize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;优点-1&quot;&gt;优点&lt;/h4&gt;

&lt;p&gt;相比于原始的 GC 复制算法，Cheney 方法能够更好的利用内存，避免了爆栈的风险。&lt;/p&gt;

&lt;h4 id=&quot;缺点-1&quot;&gt;缺点&lt;/h4&gt;

&lt;p&gt;同样，由于 bfs 的访问顺序问题，相邻的对象就不一定是其儿子对象了。相当于树的层序遍历顺序，这样其实对缓存不友好。接下来的方法就是尝试去解决这个问题。&lt;/p&gt;

&lt;h3 id=&quot;近似深度优先搜索&quot;&gt;近似深度优先搜索&lt;/h3&gt;

&lt;p&gt;这个算法是针对 Cheney 的优化。主要是考虑了内存分页问题。我们假设所有对象都一样大，每个页能放的对象个数也一样。&lt;/p&gt;

&lt;p&gt;但是这个算法如果仅仅根据书中的描述是很有局限性的。书中举得例子是有些巧合的。&lt;/p&gt;

&lt;p&gt;大体思路是这样：由于每个页的大小是有限的，所以我们争取把父子关系的对象放到一个页里。当一个节点的儿子对象被分到了新的一页的时候，就停止当前的操作，再把这个儿子的儿子对象给分配到这一页（注意这个过程不是递归的）。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$majorScan&lt;/code&gt; : 当前正在处理的第一页（也就是存在儿子对象没有复制完的对象的第一页）
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$free&lt;/code&gt; : 整个堆空间中剩余空间的开端
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$localScan[]&lt;/code&gt; 是一个数组，大小和页面数相同，第 i 个元素表示第 i 页的第一个没有处理完子对象的儿子的下标&lt;/p&gt;

&lt;p&gt;然后复制 majorScan 的时候，如果探测到子对象被安排在了新页，就跳到那一页的开始放这个子对象的子对象。放完了之后再眺回 majorScan 那一页继续复制。最终缓存友好了。&lt;/p&gt;

&lt;h3 id=&quot;多空间复制算法&quot;&gt;多空间复制算法&lt;/h3&gt;

&lt;p&gt;GC 复制算法一次使用半个堆太浪费了，但是要保证 from 不能大于 to 的大小，所以就有人提出了把堆分成多个空间。其中一个空间是 from，另一个空间是 to，在这两个空间里使用 gc 复制算法，其他的采用标记清除算法。然后每次的 from 和 to 都不一样。&lt;/p&gt;

&lt;p&gt;思路也比较简单。假设空间的标号是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[0, n-1]&lt;/code&gt; (n&amp;gt;2) , 那么我们令 0 为 to, 1 为 from，然后其他空间标记清扫，这两个空间 gc 复制。在复制之后， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;to = from, from = (from+1)%n&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;这样就综合了两种方法的优点和缺点，实际上是降低了标记清扫法每次停止的时间。然后也减少了标记清扫法产生的内存碎片问题。&lt;/p&gt;
</description>
        <pubDate>Sat, 22 Jan 2022 00:00:00 +0800</pubDate>
        <link>http://dawnk.gitee.io//%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/2022/01/22/%E7%AC%AC%E5%9B%9B%E7%AB%A0-GC%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95/</link>
        <guid isPermaLink="true">http://dawnk.gitee.io//%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/2022/01/22/%E7%AC%AC%E5%9B%9B%E7%AB%A0-GC%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95/</guid>
        
        <category>垃圾回收的算法和实现</category>
        
        
        <category>垃圾回收的算法和实现</category>
        
      </item>
    
      <item>
        <title>「垃圾回收的算法和实现」 第三章-引用计数法</title>
        <description>&lt;h1 id=&quot;引用计数法&quot;&gt;引用计数法&lt;/h1&gt;

&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;

&lt;p&gt;引用计数法的思路也是比较简单。既然当空间不足时再从头找垃圾，不如就不使用标记，在每次指针的赋值过程中就把引用的数量给维护了。一个对象，当有一个新的指针指向它的时候，计数器加 1，如果一个指针不再指向它，计数器减 1. 当计数器减为 0 的瞬间，执行回收。回收的时候还要考虑到它所有发射出的指针指向的儿子对象都要计数减 1。&lt;/p&gt;

&lt;p&gt;这种思路看起来似乎正确，但是有一个致命的问题：循环引用。&lt;/p&gt;

&lt;p&gt;根指向 A，A 指向 B，B 指向 A。然后根的指针指向别处，然后 A 和 B 的计数器都不为 1，所以就导致了内存泄漏。&lt;/p&gt;

&lt;h2 id=&quot;实现方法&quot;&gt;实现方法&lt;/h2&gt;

&lt;p&gt;在讲述优化方法之前先讲这个算法的实现。&lt;/p&gt;

&lt;p&gt;核心的算法有两个，一个是 NewPoj()，一个是 UpdatePtr()&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$freeList&lt;/code&gt; 是全局变量，是空闲链表
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reclaim(obj)&lt;/code&gt; 表示把对象所在的空间串入空闲链表。
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pickupChunk(size,$freeList)&lt;/code&gt; 表示在空闲链表中寻找合适的块（已在标记清扫法中讲过）
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;allocationFail()&lt;/code&gt; 表示分配失败，可以理解为抛出异常，自动终止程序流程&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 将 oldPtr 指向 obj 这个引用&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 根据后文的分析，这里的 obj 就当做是对象的引用来使用&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;UpdatePtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 注意必须先增加再减少，如果反过来可能会造成对象减计数之后直接被回收了&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;incObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 这里也要看做传递的引用&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;decObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;oldPtr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;incObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 这里的 obj 是引用&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;decObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 为零的时候进行释放操作&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 这里可以理解为都是指针&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;decObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;reclaim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 分配对象&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;NewObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 从空闲链表中尝试寻找合适大小的块&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pickupChunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freeList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;allocationFail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 这里可以理解为返回的是指针，也可以理解为就是返回的 longlong，不过这个 ll 和内存的值相同&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 但是就不要再想这个指针对对象的引用了，这个对象就是个临时对象，朝生暮死，不考虑它对对象的影响，它的使命就是把值传给外面&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;优点&quot;&gt;优点&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;随时整理，每次都能及时回收垃圾。最大暂停时间短&lt;/li&gt;
  &lt;li&gt;沿着指针查找次数少。仅在一个对象被回收了之后才会查找子对象。相比标记清扫法极大减少了沿对象指针的遍历次数&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;缺点&quot;&gt;缺点&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;每次指针的移动都要进行标记，减缓了速度&lt;/li&gt;
  &lt;li&gt;无法解决循环引用&lt;/li&gt;
  &lt;li&gt;计数器的大小问题，如果小了容易溢出，大了就浪费空间&lt;/li&gt;
  &lt;li&gt;UpdatePtr 这种方式过于笨重，让指针的赋值变得繁琐&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;优化&quot;&gt;优化&lt;/h2&gt;

&lt;h3 id=&quot;zct-优化&quot;&gt;zct 优化&lt;/h3&gt;

&lt;p&gt;zct 优化的方向是试图减少&lt;strong&gt;因根中的指针频繁变动&lt;/strong&gt;而造成的计数的消耗。将根指针的引用还是用普通的方法来赋值 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;oldPtr = newPtr&lt;/code&gt; , 对于堆中的还是采用上文提到的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UpdatePtr&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;然后由于缺少了对根指针引用的记录，必然导致有些计数为 0 的对象本来不是垃圾。所以不能直接清除计数为 0 的对象。我们这里采用了一个表 ZCT(Zero Count Table) 来作为一个缓冲，收留这些计数为 0 的对象。&lt;/p&gt;

&lt;p&gt;根据这个思路，刚被根创建的对象的引用数是 0。&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;decObj&lt;/code&gt; 中，如果一个对象的计数被减为 0，不要直接回收，而是把它放到 ZCT 里面。&lt;/p&gt;

&lt;p&gt;在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NewObj()&lt;/code&gt; 中，如果一个对象能够在空闲链表中找到合适的空间，就直接分配。仅仅在空闲列表中没有内存的时候，调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scanZct()&lt;/code&gt; 来操作 zct 中的对象，看看能不能释放它们。&lt;/p&gt;

&lt;p&gt;新方法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scanZct()&lt;/code&gt; ，首先把所有根指向的对象的引用值+1（这些对象可能不在 zct 中），然后遍历 zct，回收其中所有的引用为 0 的对象。遍历之后再把跟指向的对象的引用值-1.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;UpdatePtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;incObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;decObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;oldPtr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;incObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;decObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 这里仍是对象引用&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 满了就整理一下&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isFull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;scanZct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 放到 zct 表中，为了程序简洁，这里就不再写如果表满了会怎样&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 分配对象&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;NewObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pickupChunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freeList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 整理之后重试&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;scanZct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pickupChunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freeList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;allocationFail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 清除无用对象&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 实际上如果这个函数运行时一个垃圾也没回收，可以直接报错了&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 因为都是没空间的时候才会去调用它&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;scanZct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;roots&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;zct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;decObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;reclaim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;roots&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;

&lt;p&gt;这个方法的原理就是，我不去记录每次的根指针导致的对象引用计数变化。我只是在即将清除对象的时候再去检查它会不会被根节点引用了，如果没有的话就回收，有的话就让它继续在 zct 里待着。&lt;/p&gt;

&lt;p&gt;虽然书中没有说，但是我感觉到，书中对 指针的转移，语焉不详。这里写的是根指针的引用不需要计数，比如根引用对象 A，然后根又指向对象 B 了，也就是放弃了对 A 的引用，那么岂不是 A 的计数器永远不会少了？然后也不会被加入到 zct 中。同样的道理，一旦加入了 zct 中，就再也没有出来的机会了。&lt;/p&gt;

&lt;p&gt;这种方法减少了部分对计数器的操作。但是在 zct 满的时候会进行一次扫描，这个操作是费时的，也就消除了引用计数法的一大优势，也就是 STW 短。&lt;/p&gt;

&lt;p&gt;而且这个算法的效率也受 zct 的大小制约。如果 zct 过小，则清理的次数多，如果 zct 过大，则单次清理的时间长。&lt;/p&gt;

&lt;h3 id=&quot;sticky-引用计数法&quot;&gt;Sticky 引用计数法&lt;/h3&gt;

&lt;p&gt;这个算法的思路是针对于计数器占用空间的大小进行优化。这个算法基于两个经验：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;引用计数不会很大，大部分对象都是出生之后不久就会死亡，不会有太多计数&lt;/li&gt;
  &lt;li&gt;被大量引用的对象在未来的一段时间内大概率不是垃圾&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个可以了理解为，大部分对象不会有太多引用，而有大量引用的对象很难成为垃圾，也就是有很长的寿命。&lt;/p&gt;

&lt;p&gt;基于这个，我们就可以把计数器设置的小一点，比如 5 位，也就是最多 31 个对象引用它。&lt;/p&gt;

&lt;p&gt;而面对溢出这个计数器的对象，也有两种思路。第一种是直接不管了，反正这样的对象很少很少。第二种思路是采用标记清扫法来作为备份。我们主要讨论第二种。&lt;/p&gt;

&lt;p&gt;书中对此处的标记清扫法进行了魔改。我理解的是这里的操作是为了兼容计数器而不是之前说的标记。在标记前将所有对象的计数器全部清零。然后在标记完之后，每个对象的计数器也达到了正确的数量。然后清扫计数器为 0 的。&lt;/p&gt;

&lt;p&gt;这样就解决了溢出的对象，然后也减少了计数器的空间占用，并且还能回收循环引用。唯一的缺点就是让 STW 变大了。&lt;/p&gt;

&lt;h3 id=&quot;一位引用计数&quot;&gt;一位引用计数&lt;/h3&gt;

&lt;p&gt;此外还有更激进的改法，就是直接把计数器改成 1 位，只有 0 和 1.&lt;/p&gt;

&lt;p&gt;这个思路是这样的，我们在 decObj 的时候是先减后判断。其实我们完全可以先特判它是不是 1，也就是 0 这个状态是无用的。所以在这个算法中，0 表示 1, 1 表示大于等于 2. 书中称之为标签。0 是 Unique, 1 是 Multiple.&lt;/p&gt;

&lt;p&gt;这里还使用了内存对齐的黑科技，来存储这个比特（因为没法直接申请 1 比特）。书中假定的都是 32 位系统，所有的对象都按照四字节对齐也就是对象占据的内存的首地址必须是 4 的倍数，也就是首地址末尾的两个 bit 一定是 0，所以指向这个对象的指针的值的最后两位也都是 0.&lt;/p&gt;

&lt;p&gt;换言之，一个指针除了它指向的位置之外，还可以存储一个标签，用于指明这个指针指向的对象引用是 1 还是更多，这个标签是在指针上存储，所以不会占据对象的空间。&lt;/p&gt;

&lt;p&gt;将 UpdatePtr 换成了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CopyPtr(oldPtr,newPtr)&lt;/code&gt; ，也就是直接针对两个指针进行复制操作。这个有点类似 c++中 shared_ptr 的复制操作。&lt;/p&gt;

&lt;p&gt;可以分析出，&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;oldPtr 如果是 Unique，则指向的对象就可以直接回收了。&lt;/li&gt;
  &lt;li&gt;如果 newPtr 指向的对象只有一个引用，也就是 newPtr 本身的标签是 Unique，那么在这次复制之后，必然变成 Multiple. 而 oldPtr 一定会变成 Multiple&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// 将 UpdatePtr 改成这个，其他的都不用变&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CopyPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UNIQUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;reclaim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;oldPtr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UNIQUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;newPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MULTIPLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;oldPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MULTIPLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个优化思路是极大减少了对内存的占用，并且在指针操作的时候不用对对象本身有任何操作，甚至不用读取对象本身。对 cache 比较友好，而在&lt;strong&gt;对计数器溢出的对象则是采用完全不管的方式，只要一个对象被两个指针引用了，那么就再也不会被回收了&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;部分标记清扫法&quot;&gt;部分标记清扫法&lt;/h3&gt;

&lt;p&gt;这个方法实际上比较冗长，效果也不好，相关资料也少。不过 PHP 里面就是这种方法，我们就简单说一下。这种染色的思想也被 go 语言吸纳了一部分，之后会通过 go 的 gc 算法来详细地讲述并行时候的实现（虽然书上没有）。&lt;/p&gt;

&lt;p&gt;这个算法可以参考下面的资料，不过实际上论文实现的要复杂很多很多，论文还讲述了这个算法的并行形式。书中只是举了个非常简化版的说明。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.php.net/manual/en/features.gc.collecting-cycles.php&quot;&gt;PHP 官方文档&lt;/a&gt;
&lt;a href=&quot;https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon01Concurrent.pdf&quot;&gt;IBM 论文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;核心思想是通过引入标记清扫法来解决循环引用问题。但是直接使用标记清扫法会带来很大的开销。既然为了消除循环引用，那么我们的标记清扫法也要针对这个问题进行魔改。我们只关注可能是循环引用的对象群。&lt;/p&gt;

&lt;p&gt;规定四种颜色代表四种状态：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;黑色，表示绝对不会是垃圾&lt;/li&gt;
  &lt;li&gt;白色，表示一定是垃圾&lt;/li&gt;
  &lt;li&gt;灰色，已经搜索完毕，但是还不能判定是黑白&lt;/li&gt;
  &lt;li&gt;阴影 (HATCH)，可能是循环垃圾，往往阴影对象都会放到阴影队列中 ($hatch_queue)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们经过染色，将对象最终染成黑白两色，把白色的给回收即可。&lt;/p&gt;

&lt;p&gt;至于颜色，用两个位来表示，就存储的对象的头上。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;刚创建的对象一定是黑色，计数为 1&lt;/li&gt;
  &lt;li&gt;减少对象引用的时候，如果引用为 0，那就直接照上文进行回收以及对子对象的减计数即可，同时如果在队列中也记得删除。如果引用不为 0，那么就把它加到队列中并涂成阴影（如果已经是阴影就表示已经在队列，就不用添加）&lt;/li&gt;
  &lt;li&gt;当且仅当分配对象没有空间的时候，才会去选择调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scanHatchQueue()&lt;/code&gt;方法，然后尝试重新运行 newObj（注意这里不是重新到空闲链表去找，而是重新运行整个方法，这也就意味着可能要连着回收好几次阴影队列中的对象。这是一个新方法，也是我们的重头戏。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个方法就是遍历队列，遇到阴影对象就尝试探索它是不是在一个对象群中。如果是，就对这个群进行染色和回收，然后算法就结束了，也就是一次只回收一个对象群。否则就寻找队列中下一个对象。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;decObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;decObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;reclaim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HATCH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 标记为阴影并且加入队列&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HATCH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hatch_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;NewObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pickupChunk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freeList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hatch_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;scanHatchQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 一直重试到找到对象或者队列为空&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newObj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;allocationFail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 尝试回收第一个对象群&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;scanHatchQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hatch_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HATCH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;paintGray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;scanGray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;collectWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hatch_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;scanHatchQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;paintGray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 这里的意思是 灰色不用染色， 白色是垃圾，不能染色&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BLACK&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HATCH&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GRAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 这里乍看比较突兀，似乎和染色没有关系&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// 实际上是为下文 scanGray 的判断循环引用设置条件&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;paintGray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里先暂停一下，我们探讨一个环的性质。如果一群对象构成了一个环（不一定是简单环，复杂的环也可以），那么从任何一个点出发，沿着有向边 dfs 去减另一个阴影对象的计数，那么必然最终会减到自己，把自己减为 0。&lt;/p&gt;

&lt;p&gt;换言之，&lt;strong&gt;从垃圾环（也就是循环引用的垃圾群）中任意一个对象出发，沿着引用的指针减去其子对象的引用计数，并且将自身染成灰色，那么最终会得到一堆引用计数为 0 的灰色对象&lt;/strong&gt;，而如果最终这个对象自身并没有被减到 0，那么说明他不存在于任何垃圾环中。&lt;/p&gt;

&lt;p&gt;而且必须是要自己被循环回来的指针给减计数，否则假设根有两个指针指向 A，A 指向 B，B 指向 C，C 不向外指。那么根的一个指针不再指向 A 的时候，顺着过去这三个都会被识别成垃圾。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;scanGray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 只扫描灰色的，别的颜色的不管&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GRAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WRITE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;scanGray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;paintBlack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 执行到这个函数说明 obj 虽然是灰色，但是引用计数并不为 0&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 所以就需要撤销&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;paintBlack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLACK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLACK&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GRAY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// 这里的逻辑和之前的一样，不是给自己加而是给儿子加&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;paintBlack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;collectWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WRITE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 避免无限递归&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BLACKED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)){&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;collectWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;reclaim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个算法在垃圾回收的时候要扫描三次对象，效率比较低下。&lt;/p&gt;
</description>
        <pubDate>Fri, 21 Jan 2022 00:00:00 +0800</pubDate>
        <link>http://dawnk.gitee.io//%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/2022/01/21/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95/</link>
        <guid isPermaLink="true">http://dawnk.gitee.io//%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/2022/01/21/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95/</guid>
        
        <category>垃圾回收的算法和实现</category>
        
        
        <category>垃圾回收的算法和实现</category>
        
      </item>
    
      <item>
        <title>「垃圾回收的算法和实现」 第二章-标记清扫法</title>
        <description>&lt;h1 id=&quot;标记-清除算法&quot;&gt;标记-清除算法&lt;/h1&gt;

&lt;p&gt;标记清除算法是一个经典的算法，思路也比较直接和简单。&lt;/p&gt;

&lt;p&gt;需要一个全局变量 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;free_list&lt;/code&gt; , 是一个链表，用来存储空闲的块&lt;/p&gt;

&lt;h2 id=&quot;申请空间&quot;&gt;申请空间&lt;/h2&gt;

&lt;p&gt;在空闲列表中遍历，如果找到”合适”的，就把这一节摘下来，然后裁剪成 size 的大小，返回，然后将剩下的边角料给放回到列表里。&lt;/p&gt;

&lt;p&gt;如果没有合适的，就执行垃圾回收，然后再次尝试在空闲列表中寻找。找到了就返回，没找到就报错。&lt;/p&gt;

&lt;p&gt;关于“合适” 也有一些讲究。有三种常用的方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;最先匹配： 从头遍历链表，第一个大于等于 size 的节点用来分配。&lt;/li&gt;
  &lt;li&gt;最优匹配：从头遍历链表，分配大于等于 size 节点中的空间最小的节点，也就是让剩余的空间尽可能小。&lt;/li&gt;
  &lt;li&gt;最差匹配： 每次都找最大的分配。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一种方案是比较常用的。最优匹配可能会造成很多无法利用的小碎片，最差匹配可能面对大的对象时无力分配。&lt;/p&gt;

&lt;h2 id=&quot;垃圾回收&quot;&gt;垃圾回收&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;从根出发，dfs 找到所有能够直接或间接引用到的对象，然后标记其为 True&lt;/li&gt;
  &lt;li&gt;遍历堆中的对象，如果标记为 True，就置为 Flase，然后跳到下一个对象。如果标记为 False, 那么就把它串到空闲列表上。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在第二步的时候有个有趣的优化，就是如果我们发现当前回收的对象是和它左边的对象的地址是连续的，那么我们直接把它和左边的对象合并成一个对象就可以了，这样就可以减少链表的长度。&lt;/p&gt;

&lt;p&gt;从定义出发，如果根无法直接或间接引用的对象，就是垃圾。&lt;/p&gt;

&lt;h2 id=&quot;优点&quot;&gt;优点&lt;/h2&gt;

&lt;p&gt;实现简单。而且可以兼容保守式 gc（因为这种方法不会移动对象的位置，对象申请时候在哪就在哪）&lt;/p&gt;

&lt;h2 id=&quot;缺点&quot;&gt;缺点&lt;/h2&gt;

&lt;p&gt;首先是效率低，每次垃圾清扫都要遍历堆中所有对象。分配对象时候的时间复杂度也取决于链表的长度。&lt;/p&gt;

&lt;p&gt;然后是这种方法可能会形成很多碎片，也就是在一个个活动对象之间存在着很小的空间，就难以利用。&lt;/p&gt;

&lt;p&gt;最后是和写时复制不兼容。因为要改动对象的头。比如子进程刚刚创建，和父进程共享所有的对象，只要不发生写入，那么对象就不会复制。然后执行标记的时候，就会把所有的活动对象都会影响到，会触发 linux 的复制机制，导致了性能的降低。&lt;/p&gt;

&lt;h2 id=&quot;优化&quot;&gt;优化&lt;/h2&gt;

&lt;p&gt;这本书中讲了许多针对标记清除算法的优化。&lt;/p&gt;

&lt;h3 id=&quot;多链表搜索&quot;&gt;多链表搜索&lt;/h3&gt;

&lt;p&gt;算法的瓶颈之一是链表搜索效率低。如果我们设定一个上限 limit，针对长度在 [2, limit] 区间内的长度分别设置一个链表，然后将所有大于 limit 的分块放在一个单独的链表中。这样就提高了搜索效率。&lt;/p&gt;

&lt;p&gt;似乎 c++里面的 STL 的分配器也采用了相似的思路。通过一个内存池和若干空闲链表来分配内存，每次空闲链表为空的时候就去内存池申请，申请多个空间（比如要 2 个空间，就申请 20 个空间），将多余的部分放在链表中，就不必每次都问内存池了。然后当内存池不足的时候就进行 malloc，如果 malloc 也失败，就尝试把其他链表给回收了，然后凑出内存。&lt;/p&gt;

&lt;h3 id=&quot;bibop&quot;&gt;BiBop&lt;/h3&gt;

&lt;p&gt;BiBop 是 Big Bag Of Pages 的缩写。表示将内存中分成若干个块，每个块内我们让其只存储特定字长的对象。比如第 1 块只存长度为 3 的对象，第 2 块只存长度为 4 的对象。这样块内其实就没有碎片了，但是由于块是预先划分的，所以可能导致了别的块内存不足而某些块的内存闲置了。我们会在之后再次见到这个算法。&lt;/p&gt;

&lt;h3 id=&quot;位图标记&quot;&gt;位图标记&lt;/h3&gt;

&lt;p&gt;这个优化主要是针对前文提到的对写时复制不兼容的问题。&lt;/p&gt;

&lt;p&gt;我们发现之前的不兼容是因为标记在了对象的本身上（其实标记成 0 还是 1 无所谓，主要是这个标记活动对象的动作导致了无谓的复制）。&lt;/p&gt;

&lt;p&gt;我们尝试将标记不要打在对象本身，而是单独拿一个位图，也就是一个位数组，来存储这个标记。比如我们把位图放在最后，然后将前面全部的&lt;strong&gt;字&lt;/strong&gt;都按顺序映射到位图中的一个&lt;strong&gt;位&lt;/strong&gt;。显然一个对象可能对应多个连续的位。&lt;/p&gt;

&lt;p&gt;在 dfs 的时候遍历指针得到对象，这一步和之前一样。但是在打标记的时候就打到对应的位上，也就是打到一个对象的首地址对应的位上，这样就不会触发复制。&lt;/p&gt;

&lt;p&gt;在遍历堆来寻找不活动对象的时候，就直接遍历位图，没有标记的就是垃圾。考虑到缓存，遍历位图和清空位图上的位可以达到很高的效率。&lt;/p&gt;

&lt;p&gt;在多个堆的时候要给每一个堆都设置一个位图。&lt;/p&gt;

&lt;h3 id=&quot;延迟清除法&quot;&gt;延迟清除法&lt;/h3&gt;

&lt;p&gt;由于每次垃圾回收所需要的计算都很大，实际上我们只需要找到一个合适的空间就能进行下去，没必要一次就把所有的空闲空间都找到。&lt;/p&gt;

&lt;p&gt;所以我们在遍历堆的时候，找到一个合适的空间就直接停止，返回这个空间，下次不够了先别标记，先继续上次的位置找，找到了就返回，找到头了还没有就标记，然后从头开始再扫，这次要是还没找到就报错。&lt;/p&gt;

&lt;p&gt;但是实际上这个未必能提升速度，比如上次暂停的位置正好是垃圾堆的最后，再次遍历的时候就要遍历很多活动对象，然后找不到，再次标记，然后才能知道。所以就耗费了大量的时间，未必有直接找快。&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Jan 2022 00:00:00 +0800</pubDate>
        <link>http://dawnk.gitee.io//%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/2022/01/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%A0%87%E8%AE%B0%E6%B8%85%E6%89%AB%E6%B3%95/</link>
        <guid isPermaLink="true">http://dawnk.gitee.io//%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/2022/01/20/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%A0%87%E8%AE%B0%E6%B8%85%E6%89%AB%E6%B3%95/</guid>
        
        <category>垃圾回收的算法和实现</category>
        
        
        <category>垃圾回收的算法和实现</category>
        
      </item>
    
      <item>
        <title>「垃圾回收的算法和实现」 第一章-背景介绍</title>
        <description>&lt;h1 id=&quot;背景&quot;&gt;背景&lt;/h1&gt;

&lt;p&gt;最近看了一本书，《垃圾回收的算法和实现》，感觉挺有趣的，图示很多。很久没写笔记了，这本书看完了很多细节容易忘，而且有一些内容在书中描述的有些不太好理解，做笔记做备忘。&lt;/p&gt;

&lt;p&gt;垃圾回收 (gc) 是一种很久历史的功能。早在 lisp 上就已经实现了。但是关于它的研究却未停止过。部分语言比如 Java/Python/Go 已经内置了 gc，使用者无需关心内存管理，放心 new 就是了。但是在 c++等语言上并没有垃圾回收，但是可以看到 c++的智能指针也参照了一些 gc 算法的实现。在后来我们会看到语言原生支持 gc 和给一个语言设计者没考虑过 gc 的语言加 gc 的困难程度是不一样的。&lt;/p&gt;

&lt;h2 id=&quot;模型&quot;&gt;模型&lt;/h2&gt;

&lt;p&gt;此书的模型是很简单的。之后会补一些图，现在博客里图的方式太原始了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;堆&lt;/code&gt;就是一个类似数组的连续的内存空间。只有一个堆，我们假定其不能扩容。下文提到的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;遍历堆&lt;/code&gt;如果没有额外说明，就是自左到右遍历堆中的所有对象。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;对象&lt;/code&gt;就是由若干字节组成的整体。一个对象有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;头&lt;/code&gt;和若干个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;域&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;头往往用来存一些 gc 用的信息，而域才是代码中常常用到的，但是在很多算法中，垃圾的域会被重新利用来存储 gc 的信息。&lt;/li&gt;
  &lt;li&gt;一个域要么是指针类型，要么是基本类型（比如 int, float)，为了简单我们认为一个域只有一个字那么长。&lt;/li&gt;
  &lt;li&gt;我们暂且假设从内存中就能直接辨别一个域是指针还是非指针（到之后的保守式 gc 会探讨如果不能确定的情况）。我们首先假定对象至少存在一个域存放其大小。&lt;/li&gt;
  &lt;li&gt;本书假设是 32 位机，也就是指针长度为 4，一个字长也是 4 字节&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外还有一些概念&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;根&lt;/code&gt;可以理解为 寄存器，全局变量，当前栈中的变量等。其实可以简单理解为程序如果”解释”到这一行，那么在这一行所在的语境中，能够操作的对象。无法通过根中对象找到的对象，就视为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;垃圾&lt;/code&gt;，因为在之后的程序中不可能恢复对它们的使用权了（因为没有能操控它们的对象了）。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;child(obj)&lt;/code&gt;这个方法能够返回一个数组，数组里面是 obj 对象的儿子的引用。所谓儿子数组，也就是遍历 obj 的所有指针域，将指向的对象的引用加入数组，最后返回这个数组。&lt;/li&gt;
  &lt;li&gt;值得注意的是，这本书中的指针与引用的关系有些混乱，很多地方的代码明明含义是传值，结果真正想表达的意思是传引用。实际上这本书中传递对象基本都看做引用就行，几乎没有传递一个对象的副本过去的。&lt;/li&gt;
  &lt;li&gt;gc 除了考虑清理所需要的总时间外，还需要考虑最大暂停时间，可以想象如果是 java 写的游戏，那么玩家对 gc 就更敏感，所以要尽可能减少最大暂停时间&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 17 Jan 2022 00:00:00 +0800</pubDate>
        <link>http://dawnk.gitee.io//%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/2022/01/17/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D/</link>
        <guid isPermaLink="true">http://dawnk.gitee.io//%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95%E5%92%8C%E5%AE%9E%E7%8E%B0/2022/01/17/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%83%8C%E6%99%AF%E4%BB%8B%E7%BB%8D/</guid>
        
        <category>垃圾回收的算法和实现</category>
        
        
        <category>垃圾回收的算法和实现</category>
        
      </item>
    
      <item>
        <title>「编程之外」 给 PDF 增加目录</title>
        <description>&lt;h1 id=&quot;给-pdf-增加目录&quot;&gt;给 PDF 增加目录&lt;/h1&gt;

&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;

&lt;p&gt;很多 pdf 电子书没有目录，在翻阅时非常不便。事实上在 windows 平台有个很好的解决方案，就是使用 FreePic2Pdf 工具进行对目录的修改。&lt;/p&gt;

&lt;h2 id=&quot;步骤&quot;&gt;步骤&lt;/h2&gt;

&lt;h3 id=&quot;提取目录&quot;&gt;提取目录&lt;/h3&gt;

&lt;p&gt;首先下载 FreePic2Pdf . 打开后在程序的右下角选择”更改 PDF”. 然后在弹出框中选择”从 pdf 中取文件”, 设置好 pdf 路径，文件夹输出路径用默认即可。
然后点击开始，发现在 pdf 同层，多了个文件夹。文件夹中有两个文件，一个是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FreePic2Pdf_bkmk.txt&lt;/code&gt; , 一个是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FreePic2Pdf.itf&lt;/code&gt; . 我们主要对前者进行修改。&lt;/p&gt;
&lt;h3 id=&quot;修改文件&quot;&gt;修改文件&lt;/h3&gt;

&lt;p&gt;txt 的格式要求是这样的：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;以缩进来表示层级，每一级缩进使用一个 tab&lt;/li&gt;
  &lt;li&gt;每一行代表一个目录项，对于每一个目录项，目录名和页码之间以一个 tab 隔开&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-BASH&quot;&gt;0x00 基本算法	1
	0x01 位运算	1
	0x02 递推和递归	11
	0x03 前缀和与差分	21
	0x04 二分	25
	0x05 排序	32
	0x06 倍增	39
	0x07 贪心	42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一步如果使用一些强大的编辑工具，比如 vim 或者正则替换工具，可以在很短的时间内完成。&lt;/p&gt;

&lt;p&gt;在修改完 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FreePic2Pdf_bkmk.txt&lt;/code&gt; 后，我们还要对偏移量做一个修正，也就是目录中的 1 在真正 pdf 中的值是多少。比如我举例的这本书的页码的第一页对应 pdf 的第 11 页。所以打开 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FreePic2Pdf.itf&lt;/code&gt; ，将里面的对应项修改，也就是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BasePage=11&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;最后回到 FreePic2Pdf , 打开”往 pdf 挂文件”, 然后选中 pdf 和文件夹，点击开始即可。&lt;/p&gt;

&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844903545498517517&quot;&gt;PDF 没有书签目录？自己动手五分钟生成！&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 27 Jul 2021 00:00:00 +0800</pubDate>
        <link>http://dawnk.gitee.io//%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/2021/07/27/%E7%BB%99PDF%E5%A2%9E%E5%8A%A0%E7%9B%AE%E5%BD%95/</link>
        <guid isPermaLink="true">http://dawnk.gitee.io//%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%96/2021/07/27/%E7%BB%99PDF%E5%A2%9E%E5%8A%A0%E7%9B%AE%E5%BD%95/</guid>
        
        <category>编程之外</category>
        
        
        <category>编程之外</category>
        
      </item>
    
      <item>
        <title>「编译原理」 编译原理基础知识</title>
        <description>&lt;h1 id=&quot;编译原理基础知识&quot;&gt;编译原理基础知识&lt;/h1&gt;

&lt;h2 id=&quot;哥德尔不完备定理&quot;&gt;哥德尔不完备定理&lt;/h2&gt;

&lt;p&gt;对于一个形式系统，它能从基本的公理推导出其他结论。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果它能推出所有的结论，那么它就是完全性的。&lt;/li&gt;
  &lt;li&gt;如果它推出的所有结论都是对的，那么它就是可靠的。
可靠性的证明容易保证，只要保证公理是对的，推导过程是对的，那么就是可靠的。
但是问题就在于完全性的证明。哥德尔证明出，&lt;strong&gt;如果一个系统能表达初等数学，那么存在一个公式，形式系统既不能推出它，也不能推出它的否定，即形式系统无法判定它&lt;/strong&gt;. 也就是再强的形式系统也具有其无法证明的陈述。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;文法&quot;&gt;文法&lt;/h2&gt;

&lt;p&gt;乔姆斯基把文法分成 4 种类型，即 0 型，1 型，2 型，和 3 型。&lt;/p&gt;

&lt;h3 id=&quot;0-型文法&quot;&gt;0 型文法&lt;/h3&gt;

&lt;p&gt;0 型文法也称短语文法，0 型文法的能力相当于&lt;strong&gt;图灵机 (Turing)&lt;/strong&gt;, 或者说任何 0 型语言都是递归可枚举的。
产生式没有任何限制。
图灵机对于任意输入，只有三种状态：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;接受&lt;/code&gt;: 正确运行到结束并且停机。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;拒绝&lt;/code&gt;: 状态转移函数无定义，落空停机。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;不停机&lt;/code&gt;（无法判定）: 一直有定义，但永不停机。
如果对于 L 语言，它的任何串的结果都是 1 或 2, 那么它任何一个串都能被判定，这样就称之为递归语言。
如果对于 L 语言，它的任何串的结果都是 1 或 2 或 3, 即如果一个串在接受集合内，就一定会接受，如果不再，就无法验证，这样就称之为递归可枚举语言。递归语言是递归可枚举语言的子集。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1-型文法&quot;&gt;1 型文法&lt;/h3&gt;

&lt;p&gt;形如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;αAβ -&amp;gt; αγβ&lt;/code&gt; , α, β 可以是空串，但 γ 必须不能是空串。1 型文法也称上下文有关法，其能力相当于&lt;strong&gt;线性界限自动机&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;2-型文法&quot;&gt;2 型文法&lt;/h3&gt;

&lt;p&gt;2 型文法也称上下文无关法，其能力相当于&lt;strong&gt;非确定的下推自动机&lt;/strong&gt;.
形如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A -&amp;gt; γ&lt;/code&gt; . 这里的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 是非终结符号， &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;γ&lt;/code&gt; 是包含非终结符号与终结符号的字串。这种文法规定的语言可以被非确定下推自动机接受。上下文无关语言为大多数程序设计语言的语法提供了理论基础。&lt;/p&gt;

&lt;h3 id=&quot;3-型文法&quot;&gt;3 型文法&lt;/h3&gt;

&lt;p&gt;3 型文法也称右线性文法，由于这种文法等价于正规式，所以也称正规文法，相当于&lt;strong&gt;有限状态自动机&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;左边必须只有一个字符，且必须是非终结符；&lt;/li&gt;
  &lt;li&gt;其右边最多只能有两个字符，且当有两个字符时第一个为非终结符而另一个为终结符。当右边只有一个字符时，此字符必须为终结符。或者右侧是空。
从文法描述语言的能力来说，&lt;strong&gt;0 型文法最强，3 型文法最弱&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;自动机&quot;&gt;自动机&lt;/h2&gt;

&lt;h3 id=&quot;图灵机&quot;&gt;图灵机&lt;/h3&gt;

&lt;p&gt;图灵机是个抽象的计算模型。它拥有一个读写头，一个无限长的纸带，一个寄存器（用以存储当前的状态，其中有个特殊的状态叫停机状态）, 一套通用的计算规则。
我们可以构造出一个特殊的图灵机，它接受任意一个图灵机 M 的编码，然后模拟 M 的运作，这样的图灵机称为通用图灵机 (Universal Turing Machine). 现代电子计算机其实就是这样一种通用图灵机的模拟，它能接受一段描述其他图灵机的程序，并运行程序实现该程序所描述的算法。但是也只是模拟，因为计算机的存储能力是有限的。
计算机的极限计算能力就是通用图灵机的计算能力。&lt;/p&gt;

&lt;h3 id=&quot;线性界限自动机&quot;&gt;线性界限自动机&lt;/h3&gt;

&lt;p&gt;线性界限自动机就是把计算固定在输入带范围上的图灵机。也就是不是无限长的纸带。&lt;/p&gt;

&lt;h3 id=&quot;下推自动机&quot;&gt;下推自动机&lt;/h3&gt;

&lt;p&gt;下推自动机 (PDA) 可以看成是一个带有附加下推存储器的有限自动机，下推存储器是一个堆栈。
如果把下推自动机扩展，允许一个有限状态自动机存取两个栈，将会得到一个能力更强的自动机，与图灵机等价。&lt;/p&gt;

&lt;h3 id=&quot;有限状态自动机&quot;&gt;有限状态自动机&lt;/h3&gt;

&lt;p&gt;自动机从初始状态 q0 起，逐一读入输入串（由输入字母表 Σ 的字母构成）的每一个字母，根据当前状态、输入字母和转移函数 δ 决定自动机的下一步状态；如果输入串结束时，自动机处于终结状态集合 F 的某一个状态，这表示自动机接受该字串；否则自动机不接受该字串。&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Mar 2021 00:00:00 +0800</pubDate>
        <link>http://dawnk.gitee.io//%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2021/03/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
        <guid isPermaLink="true">http://dawnk.gitee.io//%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2021/03/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
        
        <category>编译原理</category>
        
        
        <category>编译原理</category>
        
      </item>
    
      <item>
        <title>「AI」 人工智能基础知识</title>
        <description>&lt;h1 id=&quot;人工智能&quot;&gt;人工智能&lt;/h1&gt;

&lt;h2 id=&quot;p-和-np&quot;&gt;P 和 NP&lt;/h2&gt;

&lt;p&gt;P 类问题是指能够在多项式时间内解决的问题
NP 类问题是指能够在多项式时间内验证一个解对不对的问题，所有 P 问题都是 NP 问题。
NP-hard: 比 NP 还要难，任意一个 NP 问题都能在多项式时间规约为 NP-hard 问题
NPC: NP 完全问题，即是 NP 问题，又是 NP-hard 问题&lt;/p&gt;

&lt;p&gt;SAT 问题（第一个 NPC 问题）. 该问题的基本意思是，给定一系列布尔变量以及它的约束集，是否存在一个解使得它的输出为真。
如果找到一个多项式内能被解决的 npc 问题的解决方法，那么 P=NP.&lt;/p&gt;

&lt;h2 id=&quot;encoder-decoder&quot;&gt;encoder-decoder&lt;/h2&gt;

&lt;p&gt;encoder-decoder 结构，基本思想就是利用两个 RNN, 一个 RNN 作为 encoder, 另一个 RNN 作为 decoder.&lt;/p&gt;

&lt;p&gt;Decoder RNN 在预测的时候，需要把上一个神经元的输出作为下一个神经元的输入，不断的预测下一个词，直到预测输出了结束标志符 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;END&amp;gt;&lt;/code&gt; , 预测结束。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/80/v2-2a0191f6e80679d919d858b936544c16_720w.jpg&quot; alt=&quot;encoder-decoder&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;seq2seq&quot;&gt;seq2seq&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/147310766&quot;&gt;参考资料&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;seq2seq 属于 encoder-decoder 结构的一种。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-6c73bb4f24b93d8a640fea0ef60d1919_720w.jpg&quot; alt=&quot;seq2seq&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;transformer&quot;&gt;transformer&lt;/h2&gt;

&lt;p&gt;Transformer 的本质上是一个 Encoder-Decoder. 编码器由 6 个编码 block 组成，同样解码器是 6 个解码 block 组成，编码器的输出会作为解码器的输入。
每个 encoder 有两层，一层是 self-Attention(Multi-head) 机制，另一层是前馈神经网络。
首先可以利用 WordEmbedding 将一个单词转换成固定长度的向量表示&lt;/p&gt;

&lt;p&gt;Self-Attention 核心内容是为输入向量的每个单词学习一个权重。
对于 decoder 来讲，我们注意到有两个与 encoder 不同的地方，每个 decoder 有三层 . 一个是第一级的 Masked Multi-head, 另一个是第二级的 Multi-Head Attention 不仅接受来自前一级的输出，还要接收 encoder 的输出，第三级也是前馈神经网络。&lt;/p&gt;

&lt;h2 id=&quot;图灵测试&quot;&gt;图灵测试&lt;/h2&gt;

&lt;p&gt;让计算机来冒充人。如果不足 70%的人判对，也就是超过 30%的裁判误以为在和自己说话的是人而非计算机，那就算作成功。
2014 年 6 月 8 日，一台计算机（计算机尤金·古斯特曼并不是超级计算机，也不是电脑，而是一个聊天机器人，是一个电脑程序）成功让人类相信它是一个 13 岁的男孩，成为有史以来首台通过图灵测试的计算机。这被认为是人工智能发展的一个里程碑事件。&lt;/p&gt;

&lt;h2 id=&quot;cnn&quot;&gt;CNN&lt;/h2&gt;

&lt;p&gt;CNN 的构成是卷积层+池化层+全连接&lt;/p&gt;

&lt;h3 id=&quot;卷积层&quot;&gt;卷积层&lt;/h3&gt;

&lt;p&gt;卷积层就是一个卷积核对一个矩阵进行操作，以二维为例，卷积核作为一个小二维数组（存在自身的值）, 沿着左上角对齐矩阵，然后将重合部分的每对数进行相乘，然后将这些数相加，填入结果矩阵中，然后根据步幅移动到下一个位置，直到把结果数组填满。
对于更多维的情况，卷积核的通道数（也就是第三维的大小）和矩阵是相同的。四维的情况一般是一个批次的数据，数据的标号作为第四维。&lt;/p&gt;

&lt;h3 id=&quot;池化层&quot;&gt;池化层&lt;/h3&gt;

&lt;p&gt;池化层也叫下采样层。池化层也是一个小数组，不过自身并没有数字。他和卷积核的移动逻辑相同，就是对于重合部分，它直接取最大值（也有取平均值的）, 填入结果数组。
可以用来缩减模型的大小，提高计算速度，同时提高所提取特征的鲁棒性。在图像处理中，可以在目标平移或者旋转而导致卷积结果有偏移时进行校正（经多次池化后结果一样）, 也可以增大感受野。&lt;/p&gt;

&lt;h3 id=&quot;全连接&quot;&gt;全连接&lt;/h3&gt;

&lt;p&gt;全连接相当于一个分类器。全连接层起到将学到的”分布式特征表示”映射到样本标记空间的作用。&lt;/p&gt;

&lt;h3 id=&quot;rnn&quot;&gt;RNN&lt;/h3&gt;

&lt;p&gt;RNN 全程循环神经网络。其输出不但与当前输入和网络的权值有关，而且也与之前网络的输入有关；其允许我们对向量的序列进行操作：输入可以是序列，输出也可以是序列，在最一般化的情况下输入输出都可以是序列。
对于 NLP 来说，RNN 理论上可以往前看（往后看）任意多个词。&lt;/p&gt;

&lt;h2 id=&quot;激活函数&quot;&gt;激活函数&lt;/h2&gt;

&lt;h3 id=&quot;relu-函数&quot;&gt;ReLU 函数&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;f(x) = max(0, x)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;sigmoid&quot;&gt;sigmoid&lt;/h3&gt;

\[θ(x)=\frac{1}{1+e^{-x}}\]

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20171231114002135?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHV0aWFueW91MTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;sigmoid&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;过拟合&quot;&gt;过拟合&lt;/h2&gt;

&lt;p&gt;机器在学习全局特征的同时，又过度学习了局部特征。导致泛化能力不够。模型在训练集上表现的很好，但是在交叉验证集合测试集上表现一般。&lt;/p&gt;

&lt;h3 id=&quot;解决方案&quot;&gt;解决方案&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;增大数据Ｎ。可以直接从数据的源头获取更多的数据，也可以通过对原有的图像的旋转，平移等，获取到更多的数据。&lt;/li&gt;
  &lt;li&gt;简化模型，可能是模型太复杂，导致数据相对不足。&lt;/li&gt;
  &lt;li&gt;降低特征的数量&lt;/li&gt;
  &lt;li&gt;Dropout 指的是在训练过程中每次按一定的概率（比如 50%）随机地“删除”一部分隐藏单元（神经元）&lt;/li&gt;
  &lt;li&gt;early stopping 。每一个 epoch 结束的时候，检查准确度，如果准确度连续多次没能提升到历史最高，那么就终止训练。&lt;/li&gt;
  &lt;li&gt;集成学习方法。集成学习通过建立几个模型组合的来解决单一预测问题。它的工作原理是生成多个分类器/模型，各自独立地学习和作出预测。比如随机森林算法，它就是多个决策树的组合。&lt;/li&gt;
  &lt;li&gt;交叉验证&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;交叉验证&quot;&gt;交叉验证&lt;/h3&gt;

&lt;p&gt;交叉验证的基本思想是把在某种意义下将原始数据 (dataset) 进行分组，一部分做为训练集 (train set), 另一部分做为验证集 (validation set or test set), 首先用训练集对分类器进行训练，再利用验证集来测试训练得到的模型 (model), 以此来做为评价分类器的性能指标&lt;/p&gt;

&lt;h2 id=&quot;聚类&quot;&gt;聚类&lt;/h2&gt;

&lt;p&gt;聚类是一种无监督的学习方法。&lt;/p&gt;

&lt;h3 id=&quot;kmeans&quot;&gt;kmeans&lt;/h3&gt;

&lt;p&gt;1、定义距离，定义初始质心
2、循环计算每个点到每个质心的距离，然后确定每个点属于的类别（距离最小的）, 并记录该点到该点质心的距离
3、确认每类下的点，然后计算这一类点的平均值，并把这个值确立为该类的新质心
4、如果所有数据都确定了属于某一类（不再更新）, 则分类完成&lt;/p&gt;

&lt;h2 id=&quot;线性回归和逻辑回归&quot;&gt;线性回归和逻辑回归&lt;/h2&gt;

&lt;h3 id=&quot;线性回归&quot;&gt;线性回归&lt;/h3&gt;

&lt;p&gt;监督学习，根据数据学习映射关系，利用该映射关系对未知的数据进行预估&lt;/p&gt;

&lt;h3 id=&quot;逻辑回归&quot;&gt;逻辑回归&lt;/h3&gt;

&lt;p&gt;监督学习，解决二分类问题。逻辑回归就是将线性回归的 $(-\infty, +\infty)$结果，通过 sigmoid 函数映射到 $(0, 1)$之间。以 1/2 作为决策边界&lt;/p&gt;

&lt;h3 id=&quot;支持向量机-svm&quot;&gt;支持向量机 (SVM)&lt;/h3&gt;

&lt;p&gt;也是分类问题，最大化最近数据点，如果不能用直线划分，那么就升维，在高纬度进行划分，反映到低维上就是曲线&lt;/p&gt;
</description>
        <pubDate>Thu, 11 Mar 2021 00:00:00 +0800</pubDate>
        <link>http://dawnk.gitee.io//ai/2021/03/11/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
        <guid isPermaLink="true">http://dawnk.gitee.io//ai/2021/03/11/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
        
        <category>AI</category>
        
        
        <category>AI</category>
        
      </item>
    
  </channel>
</rss>
